// src/engines/engineGPU/types.ts
// Type definitions for GPU puzzle solver based on Puzzle Processor architecture

import type { IJK, Placement } from "../types";

// ============================================================================
// Core Data Structures (matching paper's formalization)
// ============================================================================

/**
 * Aspect set A = Cells ∪ Pieces
 * Each aspect is either a cell index or a piece flag
 */
export type AspectType = 'cell' | 'piece';

/**
 * Embedding: a specific placement of a piece covering a set of aspects
 * In the paper: e ∈ E where e ⊆ A
 */
export interface Embedding {
  pieceId: string;
  orientationId: number;
  translation: IJK;
  
  // Bitmask representation for GPU
  cellsMask: BigUint64Array;  // Which cells this embedding covers
  pieceBit: number;           // Which piece this uses (bit index)
  
  // For bucket partitioning: min cell index in this embedding
  minCellIndex: number;
}

/**
 * Compiled puzzle ready for GPU execution
 * This is the (A, E) pair from the paper, fully expanded
 */
export interface CompiledPuzzle {
  // Aspect counts
  numCells: number;           // Nc
  numPieces: number;          // Np (always 25 for Koos)
  numAspects: number;         // Na = Nc + Np
  
  // Bitmask layout
  cellsLaneCount: number;     // ceil(Nc / 64)
  
  // Cell index mapping
  cellIndexMap: Map<string, number>;  // IJK string -> bit index
  cellCoords: IJK[];                   // bit index -> IJK
  
  // Piece index mapping  
  pieceIndexMap: Map<string, number>; // pieceId -> bit index
  pieceIds: string[];                  // bit index -> pieceId
  
  // Embeddings partitioned by min cell (Ea buckets)
  embeddingBuckets: EmbeddingBucket[];
  
  // Total embedding count
  totalEmbeddings: number;
}

/**
 * Embedding bucket for aspect a
 * Contains all embeddings where min(e) = a
 */
export interface EmbeddingBucket {
  cellIndex: number;          // The aspect index a
  embeddings: Embedding[];    // Ea list
  offset: number;             // Offset into flat embedding array (for GPU)
  count: number;              // Number of embeddings in this bucket
}

// ============================================================================
// GPU State & Checkpointing
// ============================================================================

/**
 * Search state for a single GPU thread
 * ~128 bytes, fully restartable
 */
export interface ThreadCheckpoint {
  // Remaining aspects (q in the paper)
  cellsMask: BigUint64Array;  // 2×u64 for 100 cells = 16 bytes
  piecesMask: number;         // u32 for 25 pieces = 4 bytes
  
  // Search cursor
  depth: number;              // Current depth (0..25) = 1 byte
  
  // Per-depth iterator state
  iter: Uint16Array;          // Position in Ea list at each depth = 50 bytes
  choice: Uint16Array;        // Embedding index chosen (for solution reconstruction) = 50 bytes
  
  // Status
  status: ThreadStatus;
  
  // Statistics
  fitTests: number;
  nodes: number;
}

export type ThreadStatus = 
  | 'running'      // Still searching
  | 'exhausted'    // No more branches to explore
  | 'solution'     // Found a solution
  | 'budget'       // Budget exhausted, needs continuation
  ;

/**
 * Prefix: a partial search state at depth k
 * Generated by CPU, consumed by GPU
 */
export interface SearchPrefix {
  cellsMask: BigUint64Array;
  piecesMask: number;
  depth: number;
  nextCellIndex: number;      // a_next: which cell to cover next
  
  // Optional: the choices made to reach this prefix (for debugging)
  choices?: number[];
}

// ============================================================================
// GPU Buffers & Layout
// ============================================================================

/**
 * GPU buffer layout for embeddings
 * Packed for coalesced memory access
 */
export interface GPUEmbeddingBuffer {
  // Per-embedding data (32 bytes each for 100-cell puzzles)
  // [cellsMask0: u64, cellsMask1: u64, pieceBit: u32, minCell: u32, pad: u64]
  data: ArrayBuffer;
  count: number;
  bytesPerEmbedding: number;
}

/**
 * GPU buffer layout for bucket offsets
 */
export interface GPUBucketBuffer {
  // [offset: u32, count: u32] per cell
  data: Uint32Array;
  cellCount: number;
}

/**
 * GPU buffer layout for checkpoints
 */
export interface GPUCheckpointBuffer {
  data: ArrayBuffer;
  count: number;
  bytesPerCheckpoint: number;
}

// ============================================================================
// Engine Configuration & Events
// ============================================================================

export interface EngineGPUSettings {
  // Prefix generation
  prefixDepth?: number;           // k level (default: auto-tune to ~2M prefixes)
  targetPrefixCount?: number;     // Target prefix count (default: 2_000_000)
  useCPUPrefixes?: boolean;       // Use CPU solver's MRV for prefix generation (default: true)
  
  // GPU execution
  threadBudget?: number;          // Fit-tests per thread before checkpoint (default: 100_000)
  workgroupSize?: number;         // Threads per workgroup (default: 256)
  
  // Solution limits
  maxSolutions?: number;          // 0 = unlimited
  timeoutMs?: number;             // 0 = no timeout
  
  // Status reporting
  statusIntervalMs?: number;      // Default: 250
  
  // Fallback behavior
  fallbackToCPU?: boolean;        // If GPU unavailable (default: true)
  
  // View transform (for solution display)
  view?: {
    worldFromIJK: number[][];
    sphereRadiusWorld: number;
  };
}

export interface EngineGPUEvents {
  onStatus?: (status: GPUStatus) => void;
  onSolution?: (placements: Placement[]) => void;
  onDone?: (summary: GPUSummary) => void;
}

export interface GPUStatus {
  phase: 'compiling' | 'generating_prefixes' | 'gpu_search' | 'done';
  nodes: number;
  solutions: number;
  elapsedMs: number;
  prefixesGenerated?: number;
  prefixesRemaining?: number;
  gpuThreadsActive?: number;
  fitTestsPerSecond?: number;
}

export interface GPUSummary {
  solutions: number;
  totalNodes: number;
  totalFitTests: number;
  elapsedMs: number;
  reason: 'complete' | 'timeout' | 'limit' | 'canceled' | 'gpu_error';
  
  // Performance breakdown
  timing?: {
    compileMs: number;
    prefixGenMs: number;
    gpuMs: number;
    prefixCount: number;
    kernelLaunches: number;
  };
  
  // GPU info
  gpuInfo?: {
    adapter: string;
    supported: boolean;
    fallbackUsed: boolean;
  };
}

export interface EngineGPURunHandle {
  pause(): void;
  resume(): void;
  cancel(): void;
  getStats(): GPUStatus;
}

// ============================================================================
// GPU Capability Detection
// ============================================================================

export interface GPUCapability {
  supported: boolean;
  adapter?: any; // GPUAdapter when WebGPU available
  device?: any;  // GPUDevice when WebGPU available
  limits?: any;  // GPUSupportedLimits when WebGPU available
  
  // Derived capabilities
  maxWorkgroupSize: number;
  maxBufferSize: number;
  maxComputeInvocationsPerWorkgroup: number;
  
  // Reasons for unsupported
  reason?: string;
}
