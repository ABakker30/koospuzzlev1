var q=Object.defineProperty;var J=(t,e,n)=>e in t?q(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var C=(t,e,n)=>J(t,typeof e!="symbol"?e+"":e,n);function Q(t,e){for(let n=0;n<t.length;n++){let o=t[n];for(;o;){const s=o&-o,c=Z(s);e(n*64+c),o^=s}}}function Z(t){let e=0,n=t;for(;(n&1n)===0n;)n>>=1n,e++;return e}function tt(t,e){for(let n=0;n<t.length;n++)if((t[n]&~e[n])!==0n)return!1;return!0}class nt{constructor(e,n,o){C(this,"L");C(this,"R");C(this,"U");C(this,"D");C(this,"C");C(this,"rowId");C(this,"colSize");C(this,"nCols");C(this,"nPrimary");C(this,"root",0);C(this,"nodeCount");C(this,"colHeadBase",1);this.nCols=e,this.nPrimary=n,this.L=new Int32Array(o),this.R=new Int32Array(o),this.U=new Int32Array(o),this.D=new Int32Array(o),this.C=new Int32Array(o),this.rowId=new Int32Array(o),this.colSize=new Int32Array(this.colHeadBase+e+1),this.L[this.root]=this.root,this.R[this.root]=this.root,this.U[this.root]=this.root,this.D[this.root]=this.root;for(let s=1;s<=e;s++)this.C[s]=s,this.colSize[s]=0,this.U[s]=s,this.D[s]=s,this.L[s]=s-1,this.R[s]=s===e?this.root:s+1;this.L[1]=this.root,this.R[this.root]=e>=1?1:this.root,this.L[this.root]=e>=1?e:this.root,this.nodeCount=e+1}addRow(e,n){let o=-1,s=-1;for(let c=0;c<n.length;c++){const r=n[c],a=this.colHeadBase+r,i=this.nodeCount++;this.C[i]=a,this.rowId[i]=e;const u=this.U[a];if(this.U[i]=u,this.D[i]=a,this.D[u]=i,this.U[a]=i,this.colSize[a]++,o<0)o=i,s=i,this.L[i]=i,this.R[i]=i;else{const m=this.R[s];this.R[s]=i,this.L[i]=s,this.R[i]=m,this.L[m]=i,s=i}}}cover(e){this.R[this.L[e]]=this.R[e],this.L[this.R[e]]=this.L[e];for(let n=this.D[e];n!==e;n=this.D[n])for(let o=this.R[n];o!==n;o=this.R[o]){const s=this.C[o];this.D[this.U[o]]=this.D[o],this.U[this.D[o]]=this.U[o],this.colSize[s]--}}uncover(e){for(let n=this.U[e];n!==e;n=this.U[n])for(let o=this.L[n];o!==n;o=this.L[o]){const s=this.C[o];this.colSize[s]++,this.D[this.U[o]]=o,this.U[this.D[o]]=o}this.R[this.L[e]]=e,this.L[this.R[e]]=e}choosePrimaryColumnMinSize(){let e=-1,n=2147483647;for(let o=this.R[this.root];o!==this.root;o=this.R[o]){if(o-this.colHeadBase>=this.nPrimary)continue;const c=this.colSize[o];if(c<n&&(n=c,e=o,n<=1))break}return e}solve(e){const n=performance.now();let o=0,s=!1,c="complete";const r=[];let a;const i=m=>{if(performance.now()>=e.deadlineMs)return c="timeout",!1;let h=!1;for(let d=this.R[this.root];d!==this.root;d=this.R[d])if(d-this.colHeadBase<this.nPrimary){h=!0;break}if(!h)return o++,e.wantWitness&&!a&&(a=r.slice()),o>=e.limit?(s=!0,c="limit",!1):!0;const g=this.choosePrimaryColumnMinSize();if(g<0||this.colSize[g]===0)return!0;this.cover(g);for(let d=this.D[g];d!==g;d=this.D[d]){r.push(this.rowId[d]);for(let l=this.R[d];l!==d;l=this.R[l])this.cover(this.C[l]);const f=i();for(let l=this.L[d];l!==d;l=this.L[l])this.uncover(this.C[l]);if(r.pop(),!f&&(c==="limit"||c==="timeout"))return this.uncover(g),!1}return this.uncover(g),!0};i();const u=performance.now()-n;return{count:o,capped:s,reason:c,witness:a,elapsedMs:u}}}function ot(t){const e=performance.now(),n=t.limit??1e3,o=t.timeoutMs??0,s=o>0?performance.now()+o:Number.POSITIVE_INFINITY,c=!1,r=[];Q(t.open,k=>r.push(k));const a=r.length;if(a===0)return{feasible:!0,count:1,capped:!1,witness:c?[]:void 0,elapsedMs:performance.now()-e,reason:"complete"};const i=[];for(const k of Object.keys(t.remaining)){const w=Math.max(0,t.remaining[k]??0);for(let y=0;y<w;y++)i.push({pid:k,inst:y})}const u=i.length,m=a+u,h=new Map;for(let k=0;k<r.length;k++)h.set(r[k],k);const g=new Map;{let k=a;for(const w of Object.keys(t.remaining)){const y=Math.max(0,t.remaining[w]??0);y>0&&g.set(w,k),k+=y}}const d=[],f=new Set;for(const k of r){const w=t.bb.candsByTarget[k]??[];for(const y of w){if(!tt(y.mask,t.open)||(t.remaining[y.pid]??0)<=0)continue;const P=`${y.pid}:${y.ori}:${y.t.i},${y.t.j},${y.t.k}:${et(y.mask)}`;f.has(P)||(f.add(P),d.push({pid:y.pid,ori:y.ori,t:y.t,mask:y.mask,cellsIdx:y.cellsIdx}))}}if(d.length===0)return{feasible:!1,count:0,capped:!1,elapsedMs:performance.now()-e,reason:"complete"};let l=1+m;for(const k of d){const w=Math.max(0,t.remaining[k.pid]??0);l+=5*w}const I=new nt(m,a,l),p=[];for(let k=0;k<d.length;k++){const w=d[k],y=Math.max(0,t.remaining[w.pid]??0),D=g.get(w.pid);if(D===void 0)continue;const P=[];for(const E of w.cellsIdx){const R=h.get(E);if(R===void 0){P.length=0;break}P.push(R)}if(P.length===4)for(let E=0;E<y;E++){const R=p.length;p.push(w);const K=P.concat([D+E]);I.addRow(R,K)}}const{count:b,capped:M,reason:x,witness:B,elapsedMs:v}=I.solve({limit:n,deadlineMs:s,wantWitness:c}),A=b>0,S=A&&c&&B?B.map(k=>p[k]):void 0;return{feasible:A,count:b,capped:M,witness:S,elapsedMs:v,reason:x}}function et(t){let e="";for(let n=0;n<t.length;n++)e+=t[n].toString(16)+"|";return e}function z(t,e){const n=new Map;t.cells.forEach((a,i)=>n.set(F(a),i));const o=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,-1,0],[-1,1,0],[1,0,-1],[-1,0,1],[0,1,-1],[0,-1,1]],s=t.cells.map(a=>{const i=[];for(const u of o){const m=[a[0]+u[0],a[1]+u[1],a[2]+u[2]],h=n.get(F(m));h!==void 0&&i.push(h)}return i}),c=t.cells.length,r=(1n<<BigInt(c))-1n;return{id:t.id,cells:t.cells,bitIndex:n,neighbors:s,pieces:e,N:c,occMaskAll:r}}function st(t,e){const n=t.N,o=Math.ceil(n/64),s=j(o);for(let f=0;f<n;f++)$(s,f);const c=Array.from({length:n},()=>N(o));for(let f=0;f<n;f++){const l=c[f];for(const I of t.neighbors[f])$(l,I)}const r=N(o),a=N(o);for(let f=0;f<n;f++){const l=t.cells[f];(l[0]+l[1]+l[2])%2===0?$(r,f):$(a,f)}let i=0x123456789abcdefn;function u(){return i^=i<<13n,i^=i>>17n,i^=i<<43n,i}const m=[];for(let f=0;f<n;f++)m.push(u());const h=new Map;for(const f of t.pieces.keys()){const I=[];for(let p=0;p<=10;p++)I.push(u());h.set(f,I)}const g=Array.from({length:n},()=>[]);function d(f){const l=N(o),I=[];for(const p of f){const b=t.bitIndex.get(`${p[0]},${p[1]},${p[2]}`);if(b===void 0)return null;$(l,b),I.push(b)}return{mask:l,idx:I}}for(const[f,l]of t.pieces.entries())for(const I of l)for(const p of I.cells)for(let b=0;b<n;b++){const M=t.cells[b],x=M[0]-p[0],B=M[1]-p[1],v=M[2]-p[2],A=I.cells.map(w=>[w[0]+x,w[1]+B,w[2]+v]),S=d(A);if(!S)continue;const k=[x,B,v];g[b].push({pid:f,ori:I.id,t:k,mask:S.mask,cellsIdx:S.idx})}for(let f=0;f<n;f++){const l=[],I=new Set;for(const p of g[f]){const b=it(p.mask),M=`${p.pid}:${p.ori}:${b}`;I.has(M)||(I.add(M),l.push(p))}g[f]=l}return{blockCount:o,occAllMask:s,candsByTarget:g,neighborBits:c,color0Blocks:r,color1Blocks:a,zCell:m,zInv:h}}function N(t){return new BigUint64Array(t)}function j(t){return new BigUint64Array(t)}function $(t,e){const n=e/64|0,o=BigInt(e%64);t[n]|=1n<<o}function it(t){let e="";for(let n=0;n<t.length;n++)e+=t[n].toString(16)+"|";return e}function ct(t,e){const n=j(t.length);for(let o=0;o<t.length;o++)n[o]=t[o]&~e[o];return n}function O(t,e){for(let n=0;n<t.length;n++){let o=t[n];for(;o;){const s=o&-o,c=Number(lt(s)),r=n*64+c;e(r),o^=s}}}function lt(t){let e=0n,n=t;for(;(n&1n)===0n;)n>>=1n,e++;return e}function F(t){return`${t[0]},${t[1]},${t[2]}`}const U={HINT_THRESHOLD:100,SOLVE_THRESHOLD:100,COUNT_LIMIT:1e5,TIMEOUT_MS:3e5};async function rt(){try{console.log("üì¶ Loading pieces from pieces_orientations.py...");const e=await(await fetch("/data/Pieces/pieces_orientations.py")).text(),n=at(e);return console.log(`‚úÖ Loaded ${n.size} pieces with orientations`),n}catch(t){throw console.error("‚ùå Failed to load pieces:",t),t}}function at(t){console.log("üîç parsePythonPieces: Parsing Python code..."),console.log(`   Code length: ${t.length} chars`);const e=new Map,n=t.match(/PIECES\s*=\s*\{([\s\S]*)\}/);if(!n)throw console.error("‚ùå parsePythonPieces: Could not find PIECES dictionary"),new Error("Could not find PIECES dictionary in Python file");console.log("‚úÖ parsePythonPieces: Found PIECES dictionary");const o=n[1],s=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y"];for(const c of s){const a=new RegExp(`"${c}":\\s*\\[`).exec(o);if(!a)continue;let i=1,u=a.index+a[0].length;for(;u<o.length&&i>0;)o[u]==="["?i++:o[u]==="]"&&i--,u++;const m=o.substring(a.index+a[0].length,u-1),h=[],g=/\[\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\],\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\],\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\],\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\]\s*\]/g;let d=0,f;for(;(f=g.exec(m))!==null;){const l=[[parseInt(f[1]),parseInt(f[2]),parseInt(f[3])],[parseInt(f[4]),parseInt(f[5]),parseInt(f[6])],[parseInt(f[7]),parseInt(f[8]),parseInt(f[9])],[parseInt(f[10]),parseInt(f[11]),parseInt(f[12])]];h.push({id:d++,cells:l})}h.length>0&&(e.set(c,h),console.log(`  ${c}: ${h.length} orientations`))}return console.log(`üì¶ Total pieces parsed: ${e.size} (expected 25: A-Y)`),console.log(`üì¶ Piece IDs found: ${Array.from(e.keys()).join(", ")}`),e}let ft=null;function ut(t){return`${t.i},${t.j},${t.k}`}function ht(t){return Array.isArray(t)?`${t[0]},${t[1]},${t[2]}`:`${t.i},${t.j},${t.k}`}function L(t){let e=0;for(;t;)t&=t-1n,e++;return e}function dt(t,e){const n=j(e);for(let o=0;o<e;o++){const s=(1n<<64n)-1n;n[o]=t>>BigInt(o*64)&s}return n}function T(t,e,n,o){let s=0n;for(const c of e){const r=[c[0]+n[0],c[1]+n[1],c[2]+n[2]],a=t.bitIndex.get(ht(r));if(a===void 0)return null;const i=1n<<BigInt(a);if(o&i)return null;s|=i}return s}function H(t,e,n){const o=e|n;if(o===t.occMaskAll)return!0;const s=t.N;let c=-1;for(let u=0;u<s;u++){const m=1n<<BigInt(u);if((o&m)===0n){c=u;break}}if(c<0)return!0;const r=~o&t.occMaskAll;let a=0n;const i=[c];for(a|=1n<<BigInt(c);i.length;){const u=i.shift();for(const m of t.neighbors[u]){const h=1n<<BigInt(m);r&h&&!(a&h)&&(a|=h,i.push(m))}}return a===r}function _(t,e){if((t.N-L(e))%4!==0)return!1;const o=~e&t.occMaskAll;let s=-1;for(let a=0;a<t.N;a++){const i=1n<<BigInt(a);if(o&i){s=a;break}}if(s<0)return!0;let c=0n;const r=[s];for(c|=1n<<BigInt(s);r.length;){const a=r.shift();for(const i of t.neighbors[a]){const u=1n<<BigInt(i);o&u&&!(c&u)&&(c|=u,r.push(i))}}return c===o}function X(t,e,n,o){let s=-1,c=Number.POSITIVE_INFINITY;for(let r=0;r<t.N;r++){const a=1n<<BigInt(r);if(e&a)continue;let i=0;for(const[u,m]of o.entries())if(!((n[u]??0)<=0)){for(const h of m){for(const g of h.cells){const d=[t.cells[r][0]-g[0],t.cells[r][1]-g[1],t.cells[r][2]-g[2]];if(T(t,h.cells,d,e)!==null&&(i++,i>=c))break}if(i>=c)break}if(i>=c)break}if(i<c&&(c=i,s=r,c===0))return r}return s}function V(t,e){let n=0n,o=0,s=0,c=0;for(const r of e){let a=0,i=0;for(const u of r.cells){o++;const m=t.bitIndex.get(ut(u));m!=null?(n|=1n<<BigInt(m),s++,a++):(c++,i++)}i>0&&console.warn("‚ö†Ô∏è [buildOccMask] Piece has cells outside container:",{pieceId:r.pieceId,totalCells:r.cells.length,inContainer:a,outside:i,cells:r.cells})}return console.log("üî¢ [buildOccMask] Summary:",{placedPiecesCount:e.length,totalCells:o,inContainer:s,outside:c,occBits:L(n),containerSize:t.N}),n}function Y(t){const e={};for(const n of t)n.remaining==="infinite"?e[n.pieceId]=999:e[n.pieceId]=Math.max(0,n.remaining);return e}function G(t,e,n,o,s,c){if(console.log("üîé dfsSolvable start",{depth:o,occ:n.occ.toString(16)}),Date.now()>c||o>s)return!1;if(n.occ===t.occMaskAll)return console.log("‚úÖ Solution found at depth",o),!0;const r=X(t,n.occ,n.remaining,e);if(r<0)return console.log("‚ö†Ô∏è No target cell selected (dead end)"),!1;const a=t.cells[r];if(o===0){console.log("üîé Debug at depth 0:"),console.log("  target:",a),console.log("  piecesDb type:",e instanceof Map?"Map":"Object"),console.log("  piecesDb keys sample:",e instanceof Map?Array.from(e.keys()).slice(0,3):Object.keys(e).slice(0,3));const g=e instanceof Map?e.values().next().value:Object.values(e)[0];g&&g[0]&&(console.log("  first orientation sample:",g[0]),console.log("  has cells?","cells"in g[0]),console.log("  has ijkOffsets?","ijkOffsets"in g[0]))}let i=0,u=0,m=0,h=0;for(const[g,d]of e.entries())if(!((n.remaining[g]??0)<=0))for(const f of d)for(const l of f.cells){const I=[a[0]-l[0],a[1]-l[1],a[2]-l[2]],p=T(t,f.cells,I,n.occ);if(p===null){u++;continue}i++;const b=t.N-L(n.occ|p);if(b%4!==0){m++,o<=2&&console.log("üö´ dfsSolvable prune: mod4",{depth:o,openAfter:b,occHex:n.occ.toString(16),maskHex:p.toString(16)});continue}if(!H(t,n.occ,p)){h++,o<=2&&console.log("üö´ dfsSolvable prune: connectivity",{depth:o,openAfter:b,occHex:n.occ.toString(16),maskHex:p.toString(16)});continue}if(n.occ|=p,n.remaining[g]--,G(t,e,n,o+1,s,c))return!0;n.occ&=~p,n.remaining[g]++}return console.log("üîé dfsSolvable at depth",o,{targetIdx:r,candidateCount:i,prunedByMask:u,prunedByMod4:m,prunedByConnectivity:h}),!1}function W(t,e,n,o,s,c,r=1e3){if(Date.now()>c||o>s)return 0;if(n.occ===t.occMaskAll)return 1;const a=X(t,n.occ,n.remaining,e);if(a<0)return 0;const i=t.cells[a];let u=0;for(const[m,h]of e.entries())if(!((n.remaining[m]??0)<=0)){if(u>=r)break;for(const g of h)for(const d of g.cells){if(u>=r)break;const f=[i[0]-d[0],i[1]-d[1],i[2]-d[2]],l=T(t,g.cells,f,n.occ);l===null||(t.N-L(n.occ|l))%4!==0||H(t,n.occ,l)&&(n.occ|=l,n.remaining[m]--,u+=W(t,e,n,o+1,s,c,r-u),n.occ&=~l,n.remaining[m]++)}}return u}async function pt(){return await rt()}async function It(t,e){console.log("üì• [checkSolvableFromPartial] Input:",{containerCells:t.containerCells.length,placedPieces:t.placedPieces.length,placedPieceIds:t.placedPieces.map(l=>l.pieceId),remainingPieces:t.remainingPieces.length,mode:t.mode});const n=t.containerCells.map(l=>[l.i,l.j,l.k]),o=z({cells:n,id:t.mode},e),s=V(o,t.placedPieces);let c=Y(t.remainingPieces);const r=o.N-L(s),a=Math.ceil(r/4)+2;if(t.mode==="single")for(const l of Object.keys(c))c[l]>a&&(c[l]=a);const i=r<=U.SOLVE_THRESHOLD;if(console.log("üß© [HintEngine] partial state for solvability:",{N:o.N,mode:t.mode,remaining:c,emptyCount:r,checkMode:i?"full":"lightweight"}),i&&r<=U.SOLVE_THRESHOLD){console.log("üéØ [HintEngine] Using DLX for solvability check (N=",r,")");try{const l=st(o),I=dt(s,l.blockCount),p=ct(l.occAllMask,I);let b=0;O(l.occAllMask,()=>{b++});let M=0;O(I,()=>{M++});let x=0;O(p,()=>{x++}),console.log("üîç [DLX Bitboard Check]:",{N:o.N,containerMaskBits:b,occBlocksBits:M,openBlocksBits:x,emptyCount:r});const B=t.mode==="single",v=B?1:1e3;console.log("üîç [SOLVABILITY-DEBUG] Starting DLX solvability check with limit:",v,"mode:",t.mode);const A=performance.now(),S=ot({open:p,remaining:c,bb:l,timeoutMs:B?5e3:U.TIMEOUT_MS,limit:v,wantWitness:!1});if(console.log("üîç [SOLVABILITY-DEBUG] DLX solvability check took",(performance.now()-A).toFixed(0),"ms"),console.log("üéØ [DLX] Result:",{feasible:S.feasible,count:S.count,capped:S.capped,elapsedMs:S.elapsedMs}),!S.feasible){let k=0;O(p,()=>{k++}),console.error("‚ùå [DLX] INFEASIBLE STATE:",{N:o.N,emptyCount:r,remaining:c,openCellsCount:k,containerCells:t.containerCells.length,placedPieces:t.placedPieces.length})}return{solvable:S.feasible,mode:"full",emptyCount:r,solutionCount:S.count,solutionsCapped:S.capped}}catch(l){console.warn("‚ö†Ô∏è [DLX] Failed, falling back to DFS:",l)}}if(!i){const l=_(o,s);return{solvable:l,mode:"lightweight",emptyCount:r,definiteFailure:!l}}const u=Date.now(),m=u+4e3,h=100,d=G(o,e,{occ:s,remaining:c},0,h,m);let f;if(d){const l={occ:s,remaining:{...c}},I=u+2e3;f=W(o,e,l,0,h,I,1e3),console.log(`üî¢ [HintEngine] Found ${f}${f>=1e3?"+":""} solutions`)}return{solvable:d,mode:"full",emptyCount:r,solutionCount:f}}async function kt(t,e){const n=t.containerCells.map(h=>[h.i,h.j,h.k]),o=z({cells:n,id:t.mode},e),s=V(o,t.placedPieces),c=Y(t.remainingPieces),r=o.N-L(s);console.log("üìä [Stats] Computing stats for partial state:",{emptyCount:r,remaining:c});let a=0;const i=gt(s,o.N);if(i!==null){const h=o.cells[i];for(const g of Object.keys(c)){if(c[g]<=0)continue;const d=e.get(g);if(d)for(const f of d){const l=f.cells;if(l.length===0)continue;const I=[h[0]-l[0][0],h[1]-l[0][1],h[2]-l[0][2]],p=T(o,l,I,s);if(!p)continue;const b=s|p;(o.N-L(b)===0||_(o,b))&&a++}}}const u=Object.values(c).reduce((h,g)=>h+g,0);let m;if(r>0&&u>0){const h=Math.min(u*5,50),g=Math.min(r,u),d=Math.pow(h,g);d>1e6?m=`‚âà10^${Math.floor(Math.log10(d))}`:d>1e3?m=`‚âà${(d/1e3).toFixed(1)}K`:m=`‚âà${Math.floor(d)}`}return console.log("üìä [Stats] Results:",{validNextMoveCount:a,estimatedSearchSpace:m}),{estimatedSearchSpace:m,validNextMoveCount:a}}function gt(t,e){for(let n=0;n<e;n++){const o=1n<<BigInt(n);if(!(t&o))return n}return null}export{It as checkSolvableFromPartial,kt as computeStatsFromPartial,pt as loadHintEnginePiecesDb};
