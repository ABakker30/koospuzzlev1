var ce=Object.defineProperty;var ae=(t,o,e)=>o in t?ce(t,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[o]=e;var P=(t,o,e)=>ae(t,typeof o!="symbol"?o+"":o,e);function fe(t,o){for(let e=0;e<t.length;e++){let r=t[e];for(;r;){const s=r&-r,u=ue(s);o(e*64+u),r^=s}}}function ue(t){let o=0,e=t;for(;(e&1n)===0n;)e>>=1n,o++;return o}function he(t,o){for(let e=0;e<t.length;e++)if((t[e]&~o[e])!==0n)return!1;return!0}class de{constructor(o,e,r){P(this,"L");P(this,"R");P(this,"U");P(this,"D");P(this,"C");P(this,"rowId");P(this,"colSize");P(this,"nCols");P(this,"nPrimary");P(this,"root",0);P(this,"nodeCount");P(this,"colHeadBase",1);this.nCols=o,this.nPrimary=e,this.L=new Int32Array(r),this.R=new Int32Array(r),this.U=new Int32Array(r),this.D=new Int32Array(r),this.C=new Int32Array(r),this.rowId=new Int32Array(r),this.colSize=new Int32Array(this.colHeadBase+o+1),this.L[this.root]=this.root,this.R[this.root]=this.root,this.U[this.root]=this.root,this.D[this.root]=this.root;for(let s=1;s<=o;s++)this.C[s]=s,this.colSize[s]=0,this.U[s]=s,this.D[s]=s,this.L[s]=s-1,this.R[s]=s===o?this.root:s+1;this.L[1]=this.root,this.R[this.root]=o>=1?1:this.root,this.L[this.root]=o>=1?o:this.root,this.nodeCount=o+1}addRow(o,e){let r=-1,s=-1;for(let u=0;u<e.length;u++){const b=e[u],S=this.colHeadBase+b,y=this.nodeCount++;this.C[y]=S,this.rowId[y]=o;const I=this.U[S];if(this.U[y]=I,this.D[y]=S,this.D[I]=y,this.U[S]=y,this.colSize[S]++,r<0)r=y,s=y,this.L[y]=y,this.R[y]=y;else{const w=this.R[s];this.R[s]=y,this.L[y]=s,this.R[y]=w,this.L[w]=y,s=y}}}cover(o){this.R[this.L[o]]=this.R[o],this.L[this.R[o]]=this.L[o];for(let e=this.D[o];e!==o;e=this.D[e])for(let r=this.R[e];r!==e;r=this.R[r]){const s=this.C[r];this.D[this.U[r]]=this.D[r],this.U[this.D[r]]=this.U[r],this.colSize[s]--}}uncover(o){for(let e=this.U[o];e!==o;e=this.U[e])for(let r=this.L[e];r!==e;r=this.L[r]){const s=this.C[r];this.colSize[s]++,this.D[this.U[r]]=r,this.U[this.D[r]]=r}this.R[this.L[o]]=o,this.L[this.R[o]]=o}choosePrimaryColumnMinSize(){let o=-1,e=2147483647;for(let r=this.R[this.root];r!==this.root;r=this.R[r]){if(r-this.colHeadBase>=this.nPrimary)continue;const u=this.colSize[r];if(u<e&&(e=u,o=r,e<=1))break}return o}solve(o){const e=performance.now();let r=0,s=!1,u="complete";const b=[];let S;const y=w=>{if(performance.now()>=o.deadlineMs)return u="timeout",!1;let p=!1;for(let g=this.R[this.root];g!==this.root;g=this.R[g])if(g-this.colHeadBase<this.nPrimary){p=!0;break}if(!p)return r++,o.wantWitness&&!S&&(S=b.slice()),r>=o.limit?(s=!0,u="limit",!1):!0;const A=this.choosePrimaryColumnMinSize();if(A<0||this.colSize[A]===0)return!0;this.cover(A);for(let g=this.D[A];g!==A;g=this.D[g]){b.push(this.rowId[g]);for(let M=this.R[g];M!==g;M=this.R[M])this.cover(this.C[M]);const R=y();for(let M=this.L[g];M!==g;M=this.L[M])this.uncover(this.C[M]);if(b.pop(),!R&&(u==="limit"||u==="timeout"))return this.uncover(A),!1}return this.uncover(A),!0};y();const I=performance.now()-e;return{count:r,capped:s,reason:u,witness:S,elapsedMs:I}}}function pe(t){const o=performance.now(),e=t.limit??1e3,r=t.timeoutMs??0,s=r>0?performance.now()+r:Number.POSITIVE_INFINITY,u=!0,b=[];fe(t.open,$=>b.push($));const S=b.length;if(S===0)return{feasible:!0,count:1,capped:!1,witness:u?[]:void 0,elapsedMs:performance.now()-o,reason:"complete"};const y=[];for(const $ of Object.keys(t.remaining)){const D=Math.max(0,t.remaining[$]??0);for(let T=0;T<D;T++)y.push({pid:$,inst:T})}const I=y.length,w=S+I,p=new Map;for(let $=0;$<b.length;$++)p.set(b[$],$);const A=new Map;{let $=S;for(const D of Object.keys(t.remaining)){const T=Math.max(0,t.remaining[D]??0);T>0&&A.set(D,$),$+=T}}const g=[],R=new Set;for(const $ of b){const D=t.bb.candsByTarget[$]??[];for(const T of D){if(!he(T.mask,t.open)||(t.remaining[T.pid]??0)<=0)continue;const q=`${T.pid}:${T.ori}:${T.t.i},${T.t.j},${T.t.k}:${ge(T.mask)}`;R.has(q)||(R.add(q),g.push({pid:T.pid,ori:T.ori,t:T.t,mask:T.mask,cellsIdx:T.cellsIdx}))}}if(g.length===0)return{feasible:!1,count:0,capped:!1,elapsedMs:performance.now()-o,reason:"complete"};let M=1+w;for(const $ of g){const D=Math.max(0,t.remaining[$.pid]??0);M+=5*D}const B=new de(w,S,M),k=[];for(let $=0;$<g.length;$++){const D=g[$],T=Math.max(0,t.remaining[D.pid]??0),it=A.get(D.pid);if(it===void 0)continue;const q=[];for(const Q of D.cellsIdx){const Y=p.get(Q);if(Y===void 0){q.length=0;break}q.push(Y)}if(q.length===4)for(let Q=0;Q<T;Q++){const Y=k.length;k.push(D);const ut=q.concat([it+Q]);B.addRow(Y,ut)}}const{count:v,capped:J,reason:N,witness:c,elapsedMs:et}=B.solve({limit:e,deadlineMs:s,wantWitness:u}),L=v>0,ot=L&&u&&c?c.map($=>k[$]):void 0;return{feasible:L,count:v,capped:J,witness:ot,elapsedMs:et,reason:N}}function ge(t){let o="";for(let e=0;e<t.length;e++)o+=t[e].toString(16)+"|";return o}function me(t,o){const e=new Map;t.cells.forEach((S,y)=>e.set(_t(S),y));const r=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,-1,0],[-1,1,0],[1,0,-1],[-1,0,1],[0,1,-1],[0,-1,1]],s=t.cells.map(S=>{const y=[];for(const I of r){const w=[S[0]+I[0],S[1]+I[1],S[2]+I[2]],p=e.get(_t(w));p!==void 0&&y.push(p)}return y}),u=t.cells.length,b=(1n<<BigInt(u))-1n;return{id:t.id,cells:t.cells,bitIndex:e,neighbors:s,pieces:o,N:u,occMaskAll:b}}function we(t){const o=t.N,e=Math.ceil(o/64),r=dt(e);for(let g=0;g<o;g++)nt(r,g);const s=Array.from({length:o},()=>st(e));for(let g=0;g<o;g++){const R=s[g];for(const M of t.neighbors[g])nt(R,M)}const u=st(e),b=st(e);for(let g=0;g<o;g++){const R=t.cells[g];(R[0]+R[1]+R[2])%2===0?nt(u,g):nt(b,g)}let S=0x123456789abcdefn;function y(){return S^=S<<13n,S^=S>>17n,S^=S<<43n,S}const I=[];for(let g=0;g<o;g++)I.push(y());const w=new Map;for(const g of t.pieces.keys()){const M=[];for(let B=0;B<=10;B++)M.push(y());w.set(g,M)}const p=Array.from({length:o},()=>[]);function A(g){const R=st(e),M=[];for(const B of g){const k=t.bitIndex.get(`${B[0]},${B[1]},${B[2]}`);if(k===void 0)return null;nt(R,k),M.push(k)}return{mask:R,idx:M}}for(const[g,R]of t.pieces.entries())for(const M of R)for(const B of M.cells)for(let k=0;k<o;k++){const v=t.cells[k],J=v[0]-B[0],N=v[1]-B[1],c=v[2]-B[2],et=M.cells.map($=>[$[0]+J,$[1]+N,$[2]+c]),L=A(et);if(!L)continue;const ot=[J,N,c];p[k].push({pid:g,ori:M.id,t:ot,mask:L.mask,cellsIdx:L.idx})}for(let g=0;g<o;g++){const R=[],M=new Set;for(const B of p[g]){const k=Ht(B.mask),v=`${B.pid}:${B.ori}:${k}`;M.has(v)||(M.add(v),R.push(B))}p[g]=R}return{blockCount:e,occAllMask:r,candsByTarget:p,neighborBits:s,color0Blocks:u,color1Blocks:b,zCell:I,zInv:w}}function st(t){return new BigUint64Array(t)}function dt(t){return new BigUint64Array(t)}function nt(t,o){const e=o/64|0,r=BigInt(o%64);t[e]|=1n<<r}function Ft(t,o){for(let e=0;e<t.length;e++)if((t[e]&o[e])!==0n)return!1;return!0}function Se(t,o){for(let e=0;e<t.length;e++)t[e]|=o[e]}function ye(t,o){for(let e=0;e<t.length;e++)t[e]^=o[e]}function Ht(t){let o="";for(let e=0;e<t.length;e++)o+=t[e].toString(16)+"|";return o}function Ut(t,o){for(let e=0;e<t.length;e++)if(t[e]!==o[e])return!1;return!0}function Mt(t,o){const e=dt(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]|o[r];return e}function Et(t,o){const e=dt(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]&o[r];return e}function Kt(t,o){const e=dt(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]&~o[r];return e}function ft(t){let o=0;for(let e=0;e<t.length;e++){let r=t[e];for(;r;)r&=r-1n,o++}return o}function xe(t,o){const e=o/64|0,r=BigInt(o%64);return(t[e]&1n<<r)!==0n}function Wt(t,o){const e=o/64|0,r=BigInt(o%64);return(t[e]&1n<<r)===0n}function Jt(t,o){for(let e=0;e<t.length;e++){let r=t[e];for(;r;){const s=r&-r,u=Number(Ie(s)),b=e*64+u;o(b),r^=s}}}function Ie(t){let o=0n,e=t;for(;(e&1n)===0n;)e>>=1n,o++;return o}class be{constructor(o){P(this,"slots");P(this,"ways",2);P(this,"keys");P(this,"flags");this.slots=Math.floor(o/(this.ways*9)),this.keys=new BigUint64Array(this.slots*this.ways),this.flags=new Uint8Array(this.slots*this.ways)}lookup(o){const r=Number(o%BigInt(this.slots))*this.ways;for(let s=0;s<this.ways;s++){const u=r+s;if(this.keys[u]===o)return this.flags[u]}return 0}store(o,e){const s=Number(o%BigInt(this.slots))*this.ways;for(let u=0;u<this.ways;u++){const b=s+u;if(this.flags[b]===0||this.keys[b]===o){this.keys[b]=o,this.flags[b]=e;return}}this.keys[s]=o,this.flags[s]=e}}function Me(t,o,e,r){var Ot,Nt,Pt,zt;const s=$e(o),u=performance.now(),b=ke(s.seed??12345);function S(n,i=0){for(let l=n.length-1;l>i;l--){const h=i+Math.floor(b()*(l-i+1));[n[l],n[h]]=[n[h],n[l]]}}const I=[...(((Ot=s.pieces)==null?void 0:Ot.allow)??[...t.pieces.keys()]).sort()],w={};for(const n of I)w[n]=Math.max(0,Math.floor(((Pt=(Nt=s.pieces)==null?void 0:Nt.inventory)==null?void 0:Pt[n])??1));const p=we(t),A=new Map;for(const n of I)A.set(n,0);for(let n=0;n<t.N;n++)for(const i of p.candsByTarget[n])A.set(i.pid,(A.get(i.pid)??0)+1);I.sort((n,i)=>{const l=A.get(n)??0,h=A.get(i)??0;return l-h});const g=I.map(n=>`${n}:${A.get(n)}`).slice(0,8);if(console.log("üìä Piece order (most-constrained first):",g.join(", ")),s.shuffleStrategy==="initial"||s.shuffleStrategy==="periodicRestart"||s.shuffleStrategy==="periodicRestartTime"||s.shuffleStrategy==="adaptive"){const n=I.length,i=Math.max(3,Math.ceil(n/4));for(let l=0;l<n;l+=i){const h=Math.min(l+i,n),a=I.slice(l,h);S(a);for(let f=l;f<h;f++)I[f]=a[f-l]}console.log("üé≤ Shuffled within constraint bands")}const R=new Map;I.forEach((n,i)=>R.set(n,i));for(let n=0;n<t.N;n++)p.candsByTarget[n].sort((i,l)=>{const h=R.get(i.pid)??999,a=R.get(l.pid)??999;return h-a});console.log("üîÑ Candidates sorted by piece order");const M=p.candsByTarget.reduce((n,i)=>n+i.length,0),B=p.candsByTarget.filter(n=>n.length>0).length;if(console.log(`üìã Candidates: ${M} total across ${B}/${t.N} cells`),M===0){console.warn("‚ö†Ô∏è No candidates generated! Check piece orientations match container geometry.");const n=t.cells,i=Math.min(...n.map(d=>d[0])),l=Math.max(...n.map(d=>d[0])),h=Math.min(...n.map(d=>d[1])),a=Math.max(...n.map(d=>d[1])),f=Math.min(...n.map(d=>d[2])),x=Math.max(...n.map(d=>d[2]));console.log(`   Container range: i=[${i},${l}], j=[${h},${a}], k=[${f},${x}]`);const m=[...t.pieces.entries()][0];if(m){const[d,C]=m;console.log(`   First piece ${d}: ${C.length} orientations`),(zt=C[0])!=null&&zt.cells&&console.log(`   First orientation cells: ${JSON.stringify(C[0].cells)}`)}}let k=st(p.blockCount),v=0,J=0,N=0;const c=[];let et=0,L=0,ot=0,$=0,D=!1,T=0,it=0,q=u;const Q=new Map,Y=new Set,ut=new Set;let kt=0,$t=!1;const E=s.tt.enable?new be(s.tt.bytes??64*1024*1024):null;let pt=0;E&&console.log(`üóÇÔ∏è  Engine2: TT enabled (${((s.tt.bytes??64*1024*1024)/(1024*1024)).toFixed(0)} MB, 2-way)`);let ht=0n;for(let n=0;n<t.N;n++)p.zCell&&p.zCell[n]!==void 0&&(ht^=p.zCell[n]);let rt=0n;for(const n in w){const i=p.zInv.get(n);if(i){const l=w[n]??0;rt^=i[Math.min(l,i.length-1)]}}function lt(){return ht^rt}function Ct(n){p.zCell&&Jt(n,i=>{p.zCell[i]!==void 0&&(ht^=p.zCell[i])})}function Tt(n,i,l){const h=p.zInv.get(n);h&&(rt^=h[Math.min(i,h.length-1)],rt^=h[Math.min(l,h.length-1)])}function Rt(n){const i=new Map;for(const[h,a]of t.pieces.entries()){const f=new Map;for(const x of a)f.set(x.id,x.cells);i.set(h,f)}const l=[];for(const h of n){const a=i.get(h.pieceId);if(!a)throw new Error(`Unknown pieceId in solution: ${h.pieceId}`);const f=a.get(h.ori);if(!f)throw new Error(`Unknown orientation for ${h.pieceId}: ${h.ori}`);const x=f.map(d=>[d[0]+h.t[0],d[1]+h.t[1],d[2]+h.t[2]]),m=[];for(const d of x){const C=t.bitIndex.get(`${d[0]},${d[1]},${d[2]}`);if(C===void 0)throw new Error(`Solution cell outside container for ${h.pieceId}`);m.push(C)}m.sort((d,C)=>d-C),l.push(`${h.pieceId}:${m.join(",")}`)}return l.sort(),l.join("|")}let ct=!1,St=!1,yt=!1,G=u,xt=!1;const gt=s.view??{worldFromIJK:[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],sphereRadiusWorld:1},Vt=Math.floor(t.N/4),qt=Object.values(w).reduce((n,i)=>n+(i??0),0),Xt=Math.min(Vt,qt);let z={inventory:0,overlap:0,neighborTouch:0,colorResidue:0,multipleOf4:0,connectivity:0,ttPrune:0,total:0},vt=performance.now(),mt=0,It=0;function wt(){xt||(xt=!0,setTimeout(()=>{xt=!1,Yt()},0))}function Bt(n){var l,h;console.log(`üîÑ [RESTART] Triggering ${n}-based restart #${T+1} at ${v} nodes`),k=st(p.blockCount),c.length=0,et++,D=!0;for(const a of I)w[a]=Math.max(0,Math.floor(((h=(l=s.pieces)==null?void 0:l.inventory)==null?void 0:h[a])??1));S(I),T++;const i=new Map;I.forEach((a,f)=>i.set(a,f));for(let a=0;a<t.N;a++)p.candsByTarget[a].sort((f,x)=>{const m=i.get(f.pid)??999,d=i.get(x.pid)??999;return m-d});console.log("üîÑ Candidates resorted by new piece order"),ht=0n;for(let a=0;a<t.N;a++)p.zCell&&p.zCell[a]!==void 0&&(ht^=p.zCell[a]);rt=0n;for(const a in w){const f=p.zInv.get(a);if(f){const x=w[a]??0;rt^=f[Math.min(x,f.length-1)]}}it=v,q=performance.now(),F("search")}const Yt=()=>{if(!St){if(ct){wt();return}try{for(let i=0;i<200;i++){if(s.timeoutMs&&performance.now()-u>=s.timeoutMs){X("timeout");return}if(s.shuffleStrategy==="periodicRestart"&&v-it>=s.restartInterval&&T<s.maxRestarts){Bt("nodes");continue}if(s.shuffleStrategy==="periodicRestartTime"&&performance.now()-q>=s.restartIntervalSeconds*1e3&&T<s.maxRestarts){Bt("time");continue}if(c.length===0&&!At()){console.log("‚ùå [NO MOVES] Cannot push initial frame - no valid moves available"),console.log("   ‚îî‚îÄ This means the first piece cannot be placed anywhere (all positions pruned or invalid)"),X("complete");return}if(s.tailSwitch.enable){const f=Kt(p.occAllMask,k),x=ft(f),m=s.tailSwitch.dlxThreshold??100;if(x>0&&x<=m){const d=lt();if(ut.has(d)){const _=c[c.length-1];if(j(_),c.pop(),c.length===0){X("complete");return}const K=c[c.length-1];j(K),Z(K);const W=performance.now();W-G>=s.statusIntervalMs&&(F("search"),G=W);continue}if(E&&E.lookup(d)===1){const _=c[c.length-1];if(j(_),c.pop(),c.length===0){X("complete");return}const K=c[c.length-1];j(K),Z(K);const W=performance.now();W-G>=s.statusIntervalMs&&(F("search"),G=W);continue}const C=s.tailSwitch.dlxTimeoutMs??3e4;ut.add(d),$t=!0;let O=!1;const U=[],Lt=performance.now(),at=pe({open:f,remaining:w,bb:p,timeoutMs:C,limit:1,wantWitness:!0});if(mt+=performance.now()-Lt,It++,at.feasible&&at.witness&&at.witness.length>0){O=!0;const _=c.filter(H=>H.placed).map(H=>({pieceId:H.placed.pid,ori:H.placed.ori,t:H.placed.t})),K=at.witness.map(H=>({pieceId:H.pid,ori:H.ori,t:H.t})),W=[..._,...K],jt=Rt(W);!Y.has(jt)&&(Y.add(jt),U.push(W),N++,console.log(`‚úÖ Solution #${N} (DLX):`,W.map(H=>H.pieceId).join(",")),E&&(E.store(lt(),2),pt++),Dt(W),s.maxSolutions>0&&N>=s.maxSolutions&&(O=!0),s.pauseOnSolution&&(yt=!0,ct=!0,F("search")))}if(O){if(s.maxSolutions>0&&N>=s.maxSolutions){X("limit");return}if(ct)return;if(c.length){const _=c[c.length-1];for(_.placed&&j(_),Z(_);c.length>0&&!bt(c[c.length-1]);){const K=c.pop();K.placed&&j(K)}if(c.length===0){X("complete");return}F("search")}continue}else{E&&(E.store(lt(),1),pt++);const _=c[c.length-1];if(j(_),c.pop(),c.length===0){X("complete");return}const K=c[c.length-1];j(K),Z(K);const W=performance.now();W-G>=s.statusIntervalMs&&(F("search"),G=W);continue}}}const l=c[c.length-1],h=ne(l);if(h){se(l,h),v++;const f=c.length,x=c.filter(d=>d.placed).length;if(f>L?(L=f,$=1,D=!1):L>0&&f===L&&D&&($++,D=!1),x>ot&&(ot=x),f>kt&&(kt=f,ut.clear()),Ut(k,p.occAllMask)){const d=c.filter(U=>U.placed).map(U=>({pieceId:U.placed.pid,ori:U.placed.ori,t:U.placed.t})),C=Rt(d),O=!Y.has(C);if(O){if(Y.add(C),N++,console.log(`‚úÖ Solution #${N}:`,d.map(U=>U.pieceId).join(",")),E&&(E.store(lt(),2),pt++),Dt(d),s.maxSolutions>0&&N>=s.maxSolutions){X("limit");return}if(s.pauseOnSolution&&O){ct=!0,F("search");return}}for(j(l),Z(l);c.length>0&&!bt(c[c.length-1]);){const U=c.pop();U.placed&&j(U)}if(c.length===0){X("complete");return}F("search");continue}At()||(j(l),Z(l));continue}if(E&&(E.store(lt(),1),pt++),j(l),c.pop(),L>0&&c.length<L&&(D=!0),c.length===0){X("complete");return}if(s.shuffleStrategy==="adaptive"){const f=c.length;if(f<s.shuffleTriggerDepth){const x=f,m=Q.get(x)??0;if(m<s.maxSuffixShuffles){const C=c.filter(O=>O.placed).map(O=>O.placed.pid).length;C<I.length-1&&(console.log(`üß† [ADAPTIVE] Shuffling suffix at depth ${f} (shuffle #${m+1})`),S(I,C),console.log(`   ‚îî‚îÄ Kept first ${C} pieces, shuffled remaining ${I.length-C}`),Q.set(x,m+1),F("search"))}}}const a=c[c.length-1];j(a),Z(a)}const n=performance.now();n-G>=s.statusIntervalMs&&(F("search"),G=n)}catch(n){throw n}wt()}};function Gt(){ct=!0,F("search")}function Qt(){if(!St){if(ct=!1,yt&&(yt=!1,c.length)){const n=c[c.length-1];for(n.placed&&j(n),Z(n);c.length>0&&!bt(c[c.length-1]);){const i=c.pop();i.placed&&j(i)}}F("search"),wt()}}function Zt(){var n;St=!0,(n=e==null?void 0:e.onDone)==null||n.call(e,{solutions:N,nodes:v,elapsedMs:performance.now()-u,reason:"canceled"})}function te(){const n=c.map(l=>({targetIdx:l.targetIdx,iPiece:l.iPiece,iOri:l.iOri,iAnchor:l.iAnchor,placed:l.placed?{pieceId:l.placed.pid,ori:l.placed.ori,t:l.placed.t,maskHex:Ht(l.placed.mask)}:void 0}));let i="";for(let l=0;l<k.length;l++)l>0&&(i+="|"),i+=k[l].toString(16);return{schema:2,N:t.N,occHex:i,pieceOrder:[...I],remaining:{...w},frames:n,nodes:v,solutions:N,elapsedMs:performance.now()-u,settings:s,containerId:t.id}}return F("search"),wt(),{pause:Gt,resume:Qt,cancel:Zt,snapshot:te};function ee(n){const i=ft(n);if(i&3)return!1;const l=ft(Et(n,p.color0Blocks)),h=i-l;return!(l&1||h&1)}function oe(n,i){for(const l of n.cellsIdx){const h=p.neighborBits[l];for(let a=0;a<h.length;a++)if((h[a]&i[a])!==0n)return!0}return!1}function At(){const n=s.moveOrdering==="mostConstrainedCell"?re(k,w):ie(k,t.N);return n<0?!1:(c.push({targetIdx:n,iPiece:0,iOri:0,iAnchor:0,placed:void 0}),!0)}function ne(n){const i=p.candsByTarget[n.targetIdx],l=c.length;s.randomizeTies&&n.iAnchor===0&&i.length>1&&(n.iAnchor=Math.min(i.length-1,n.iAnchor+Math.floor(b()*(i.length-n.iAnchor))));let h=0,a={inventory:0,overlap:0,neighborTouch:0,colorResidue:0,multipleOf4:0,connectivity:0,ttPrune:0};for(;n.iAnchor<i.length;n.iAnchor++){h++;const f=i[n.iAnchor];if((w[f.pid]??0)<=0){z.inventory++,a.inventory++;continue}if(!Ft(k,f.mask)){z.overlap++,a.overlap++;continue}const x=ft(k);if(s.pruning.neighborTouch&&x>0&&!oe(f,k)){J++,z.neighborTouch++,a.neighborTouch++;continue}if(s.pruning.colorResidue){const d=Kt(p.occAllMask,Mt(k,f.mask));if(!ee(d)){J++,z.colorResidue++,a.colorResidue++;continue}}if(s.pruning.multipleOf4&&(t.N-ft(Mt(k,f.mask)))%4!==0){J++,z.multipleOf4++,a.multipleOf4++;continue}if(s.pruning.connectivity&&!le(k,f.mask)){J++,z.connectivity++,a.connectivity++;continue}if(E){let d=lt();for(const at of f.cellsIdx)d^=p.zCell[at];const C=p.zInv.get(f.pid),O=w[f.pid]??0,U=O-1;if(d^=C[Math.min(O,C.length-1)],d^=C[Math.min(U,C.length-1)],E.lookup(d)===1){J++,z.ttPrune++,a.ttPrune++;continue}}const m=performance.now();if(m-vt>=1e4){const d=Object.values(z).reduce((C,O)=>C+O,0);console.log(`üîç [PRUNING STATS] Depth ${l}, Total pruned: ${d.toLocaleString()}`),console.log(`   ‚îú‚îÄ Inventory: ${z.inventory.toLocaleString()}`),console.log(`   ‚îú‚îÄ Overlap: ${z.overlap.toLocaleString()}`),console.log(`   ‚îú‚îÄ NeighborTouch: ${z.neighborTouch.toLocaleString()}`),console.log(`   ‚îú‚îÄ ColorResidue: ${z.colorResidue.toLocaleString()}`),console.log(`   ‚îú‚îÄ MultipleOf4: ${z.multipleOf4.toLocaleString()}`),console.log(`   ‚îú‚îÄ Connectivity: ${z.connectivity.toLocaleString()}`),console.log(`   ‚îî‚îÄ TT Prune: ${z.ttPrune.toLocaleString()}`),vt=m}return{pid:f.pid,ori:f.ori,t:f.t,mask:f.mask,cellsIdx:f.cellsIdx}}return h>0&&l<=5&&(console.log(`‚ùå [NO MOVES] Depth ${l}, checked ${h} candidates, all pruned`),console.log(`   ‚îú‚îÄ Inventory rejects: ${a.inventory}`),console.log(`   ‚îú‚îÄ Overlap rejects: ${a.overlap}`),console.log(`   ‚îú‚îÄ NeighborTouch rejects: ${a.neighborTouch}`),console.log(`   ‚îú‚îÄ ColorResidue rejects: ${a.colorResidue}`),console.log(`   ‚îú‚îÄ MultipleOf4 rejects: ${a.multipleOf4}`),console.log(`   ‚îú‚îÄ Connectivity rejects: ${a.connectivity}`),console.log(`   ‚îî‚îÄ TT rejects: ${a.ttPrune}`)),null}function se(n,i){Se(k,i.mask),Ct(i.mask),Tt(i.pid,w[i.pid],w[i.pid]-1),w[i.pid]--,n.placed={pid:i.pid,ori:i.ori,t:i.t,mask:i.mask,cellsIdx:i.cellsIdx}}function j(n){if(!n.placed)return;const{pid:i,mask:l}=n.placed;ye(k,l),Ct(l),Tt(i,w[i],w[i]+1),w[i]++,n.placed=void 0}function ie(n,i){for(let l=0;l<i;l++)if(Wt(n,l))return l;return-1}function re(n,i){let l=-1,h=Number.POSITIVE_INFINITY;const a=t.N;for(let f=0;f<a;f++){if(!Wt(n,f))continue;let x=0;const m=p.candsByTarget[f];for(const d of m)if(!((i[d.pid]??0)<=0)&&Ft(n,d.mask)&&(x++,x>=h))break;if(x<h&&(h=x,l=f,h===0))return f}return l}function le(n,i){const l=Mt(n,i),h=dt(p.blockCount);for(let m=0;m<p.blockCount;m++)h[m]=~l[m]&p.occAllMask[m];let a=-1;t:for(let m=0;m<p.blockCount;m++){let d=h[m];if(d===0n)continue;let C=0n;for(;(d&1n)===0n;)d>>=1n,C++;a=m*64+Number(C);break t}if(a<0)return!0;const f=st(p.blockCount),x=[a];for(nt(f,a);x.length;){const m=x.pop(),d=p.neighborBits[m],C=Et(d,h);Jt(C,O=>{xe(f,O)||(nt(f,O),x.push(O))})}return Ut(f,h)}function Z(n){n.iAnchor++}function bt(n){const i=p.candsByTarget[n.targetIdx];for(let l=n.iAnchor;l<i.length;l++){const h=i[l];if((w[h.pid]??0)>0)return!0}return!1}function Dt(n){var l,h,a;const i={engine:"dfs",phase:"search",nodes:v,depth:c.length,elapsedMs:performance.now()-u,pruned:J,placed:n.length,open_cells:0,stack:n,containerId:t.id,worldFromIJK:gt.worldFromIJK,sphereRadiusWorld:gt.sphereRadiusWorld,clear:!0,scene_version:++et};(l=s.pieces)!=null&&l.inventory&&(i.inventory_remaining={...w}),(h=e==null?void 0:e.onStatus)==null||h.call(e,i),(a=e==null?void 0:e.onSolution)==null||a.call(e,n),s.saveSolutions&&(e!=null&&e.onSaveSolutionFile)&&e.onSaveSolutionFile({index:N,placements:n,containerId:t.id,nodes:v,elapsedMs:performance.now()-u})}function F(n){var f,x;const i=c.filter(m=>m.placed).map(m=>({pieceId:m.placed.pid,ori:m.placed.ori,t:m.placed.t})),l=performance.now()-u,h=l>0?Math.round(v/l*1e3):0,a={engine:"dfs",phase:n,nodes:v,depth:c.length,elapsedMs:l,pruned:J,placed:i.length,open_cells:t.N-ft(k),stack:i,containerId:t.id,worldFromIJK:gt.worldFromIJK,sphereRadiusWorld:gt.sphereRadiusWorld,clear:!1,scene_version:et,bestDepth:L,maxDepthHits:$,bestPlaced:ot,totalPiecesTarget:Xt,nodesPerSec:h,tailTriggered:$t,restartCount:T,shuffleStrategy:s.shuffleStrategy,restartInterval:s.restartInterval,restartIntervalSeconds:s.restartIntervalSeconds};(f=s.pieces)!=null&&f.inventory&&(a.inventory_remaining={...w}),(x=e==null?void 0:e.onStatus)==null||x.call(e,a),G=performance.now()}function X(n){var l;const i=performance.now()-u;console.log(`‚úÖ DONE: ${v} nodes | ${N} solutions | ${(i/1e3).toFixed(1)}s`),console.log(`üìä Timing: DLX ${mt.toFixed(0)}ms (${It} calls), DFS ${(i-mt).toFixed(0)}ms`),F("done"),(l=e==null?void 0:e.onDone)==null||l.call(e,{solutions:N,nodes:v,elapsedMs:performance.now()-u,reason:n,timing:{totalMs:i,dlxMs:mt,dlxCalls:It,pruneStats:{...z},restartCount:T,bestDepth:L,maxDepthHits:$}})}}function _t(t){return`${t[0]},${t[1]},${t[2]}`}function ke(t){let o=t|0||1;return()=>(o^=o<<13,o^=o>>>17,o^=o<<5,(o>>>0)/4294967296)}function $e(t){var o,e,r,s,u,b,S,y,I,w;return{maxSolutions:t.maxSolutions??0,timeoutMs:t.timeoutMs??0,statusIntervalMs:t.statusIntervalMs??250,pauseOnSolution:t.pauseOnSolution??!0,saveSolutions:t.saveSolutions??!1,savePath:t.savePath??"",moveOrdering:t.moveOrdering??"mostConstrainedCell",pruning:{connectivity:((o=t.pruning)==null?void 0:o.connectivity)??!0,multipleOf4:((e=t.pruning)==null?void 0:e.multipleOf4)??!0,colorResidue:((r=t.pruning)==null?void 0:r.colorResidue)??!0,neighborTouch:((s=t.pruning)==null?void 0:s.neighborTouch)??!0},pieces:t.pieces??{},view:t.view??{worldFromIJK:[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],sphereRadiusWorld:1},seed:t.seed??12345,randomizeTies:t.randomizeTies??!0,shuffleStrategy:t.shuffleStrategy??"none",restartInterval:t.restartInterval??5e4,restartIntervalSeconds:t.restartIntervalSeconds??5,maxRestarts:t.maxRestarts??10,shuffleTriggerDepth:t.shuffleTriggerDepth??8,maxSuffixShuffles:t.maxSuffixShuffles??5,tt:{enable:((u=t.tt)==null?void 0:u.enable)??!0,bytes:((b=t.tt)==null?void 0:b.bytes)??64*1024*1024,policy:((S=t.tt)==null?void 0:S.policy)??"2way"},tailSwitch:{enable:((y=t.tailSwitch)==null?void 0:y.enable)??!0,dlxThreshold:((I=t.tailSwitch)==null?void 0:I.dlxThreshold)??100,dlxTimeoutMs:((w=t.tailSwitch)==null?void 0:w.dlxTimeoutMs)??3e4},visualRevealDelayMs:t.visualRevealDelayMs??150}}let tt=-1,V=null;self.onmessage=t=>{const o=t.data;switch(o.type){case"init":{tt=o.workerId;const e=new Map(o.pieceDB),r={...o.settings,seed:(o.settings.seed??Date.now())+tt*1e3};try{const s=me({cells:o.geometry,id:`worker-${tt}`},e);V=Me(s,r,{onStatus:u=>{const b={nodes:u.nodes??0,depth:u.depth??0,bestDepth:u.bestDepth??u.depth??0,maxDepthHits:u.maxDepthHits??0,elapsedMs:u.elapsedMs??0,nodesPerSec:u.nodesPerSec??0,restartCount:u.restartCount??0};self.postMessage({type:"status",workerId:tt,status:b})},onSolution:u=>{self.postMessage({type:"solution",workerId:tt,placements:u})},onDone:u=>{self.postMessage({type:"done",workerId:tt,summary:{solutions:u.solutions,nodes:u.nodes,elapsedMs:u.elapsedMs,reason:u.reason}})}}),V.resume(),self.postMessage({type:"ready",workerId:tt})}catch(s){self.postMessage({type:"error",workerId:tt,error:s instanceof Error?s.message:String(s)})}break}case"pause":{V==null||V.pause();break}case"resume":{V==null||V.resume();break}case"cancel":{V==null||V.cancel();break}}};
