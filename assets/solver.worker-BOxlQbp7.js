var ce=Object.defineProperty;var ae=(t,o,e)=>o in t?ce(t,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[o]=e;var z=(t,o,e)=>ae(t,typeof o!="symbol"?o+"":o,e);function fe(t,o){for(let e=0;e<t.length;e++){let i=t[e];for(;i;){const s=i&-i,a=ue(s);o(e*64+a),i^=s}}}function ue(t){let o=0,e=t;for(;(e&1n)===0n;)e>>=1n,o++;return o}function he(t,o){for(let e=0;e<t.length;e++)if((t[e]&~o[e])!==0n)return!1;return!0}class de{constructor(o,e,i){z(this,"L");z(this,"R");z(this,"U");z(this,"D");z(this,"C");z(this,"rowId");z(this,"colSize");z(this,"nCols");z(this,"nPrimary");z(this,"root",0);z(this,"nodeCount");z(this,"colHeadBase",1);this.nCols=o,this.nPrimary=e,this.L=new Int32Array(i),this.R=new Int32Array(i),this.U=new Int32Array(i),this.D=new Int32Array(i),this.C=new Int32Array(i),this.rowId=new Int32Array(i),this.colSize=new Int32Array(this.colHeadBase+o+1),this.L[this.root]=this.root,this.R[this.root]=this.root,this.U[this.root]=this.root,this.D[this.root]=this.root;for(let s=1;s<=o;s++)this.C[s]=s,this.colSize[s]=0,this.U[s]=s,this.D[s]=s,this.L[s]=s-1,this.R[s]=s===o?this.root:s+1;this.L[1]=this.root,this.R[this.root]=o>=1?1:this.root,this.L[this.root]=o>=1?o:this.root,this.nodeCount=o+1}addRow(o,e){let i=-1,s=-1;for(let a=0;a<e.length;a++){const g=e[a],y=this.colHeadBase+g,m=this.nodeCount++;this.C[m]=y,this.rowId[m]=o;const b=this.U[y];if(this.U[m]=b,this.D[m]=y,this.D[b]=m,this.U[y]=m,this.colSize[y]++,i<0)i=m,s=m,this.L[m]=m,this.R[m]=m;else{const x=this.R[s];this.R[s]=m,this.L[m]=s,this.R[m]=x,this.L[x]=m,s=m}}}cover(o){this.R[this.L[o]]=this.R[o],this.L[this.R[o]]=this.L[o];for(let e=this.D[o];e!==o;e=this.D[e])for(let i=this.R[e];i!==e;i=this.R[i]){const s=this.C[i];this.D[this.U[i]]=this.D[i],this.U[this.D[i]]=this.U[i],this.colSize[s]--}}uncover(o){for(let e=this.U[o];e!==o;e=this.U[e])for(let i=this.L[e];i!==e;i=this.L[i]){const s=this.C[i];this.colSize[s]++,this.D[this.U[i]]=i,this.U[this.D[i]]=i}this.R[this.L[o]]=o,this.L[this.R[o]]=o}choosePrimaryColumnMinSize(){let o=-1,e=2147483647;for(let i=this.R[this.root];i!==this.root;i=this.R[i]){if(i-this.colHeadBase>=this.nPrimary)continue;const a=this.colSize[i];if(a<e&&(e=a,o=i,e<=1))break}return o}solve(o){const e=performance.now();let i=0,s=!1,a="complete";const g=[];let y;const m=x=>{if(performance.now()>=o.deadlineMs)return a="timeout",!1;let d=!1;for(let k=this.R[this.root];k!==this.root;k=this.R[k])if(k-this.colHeadBase<this.nPrimary){d=!0;break}if(!d)return i++,o.wantWitness&&!y&&(y=g.slice()),i>=o.limit?(s=!0,a="limit",!1):!0;const I=this.choosePrimaryColumnMinSize();if(I<0||this.colSize[I]===0)return!0;this.cover(I);for(let k=this.D[I];k!==I;k=this.D[k]){g.push(this.rowId[k]);for(let P=this.R[k];P!==k;P=this.R[P])this.cover(this.C[P]);const E=m();for(let P=this.L[k];P!==k;P=this.L[P])this.uncover(this.C[P]);if(g.pop(),!E&&(a==="limit"||a==="timeout"))return this.uncover(I),!1}return this.uncover(I),!0};m();const b=performance.now()-e;return{count:i,capped:s,reason:a,witness:y,elapsedMs:b}}}function pe(t){const o=performance.now(),e=t.limit??1e3,i=t.timeoutMs??0,s=i>0?performance.now()+i:Number.POSITIVE_INFINITY,a=!0,g=[];fe(t.open,C=>g.push(C));const y=g.length;if(y===0)return{feasible:!0,count:1,capped:!1,witness:a?[]:void 0,elapsedMs:performance.now()-o,reason:"complete"};const m=[];for(const C of Object.keys(t.remaining)){const A=Math.max(0,t.remaining[C]??0);for(let $=0;$<A;$++)m.push({pid:C,inst:$})}const b=m.length,x=y+b,d=new Map;for(let C=0;C<g.length;C++)d.set(g[C],C);const I=new Map;{let C=y;for(const A of Object.keys(t.remaining)){const $=Math.max(0,t.remaining[A]??0);$>0&&I.set(A,C),C+=$}}const k=[],E=new Set;for(const C of g){const A=t.bb.candsByTarget[C]??[];for(const $ of A){if(!he($.mask,t.open)||(t.remaining[$.pid]??0)<=0)continue;const F=`${$.pid}:${$.ori}:${$.t.i},${$.t.j},${$.t.k}:${ge($.mask)}`;E.has(F)||(E.add(F),k.push({pid:$.pid,ori:$.ori,t:$.t,mask:$.mask,cellsIdx:$.cellsIdx}))}}if(k.length===0)return{feasible:!1,count:0,capped:!1,elapsedMs:performance.now()-o,reason:"complete"};let P=1+x;for(const C of k){const A=Math.max(0,t.remaining[C.pid]??0);P+=5*A}const tt=new de(x,y,P),B=[];for(let C=0;C<k.length;C++){const A=k[C],$=Math.max(0,t.remaining[A.pid]??0),Y=I.get(A.pid);if(Y===void 0)continue;const F=[];for(const Z of A.cellsIdx){const W=d.get(Z);if(W===void 0){F.length=0;break}F.push(W)}if(F.length===4)for(let Z=0;Z<$;Z++){const W=B.length;B.push(A);const ut=F.concat([Y+Z]);tt.addRow(W,ut)}}const{count:O,capped:w,reason:v,witness:c,elapsedMs:D}=tt.solve({limit:e,deadlineMs:s,wantWitness:a}),R=O>0,V=R&&a&&c?c.map(C=>B[C]):void 0;return{feasible:R,count:O,capped:w,witness:V,elapsedMs:D,reason:v}}function ge(t){let o="";for(let e=0;e<t.length;e++)o+=t[e].toString(16)+"|";return o}function me(t){const o=new Set(t.map(g=>`${g[0]},${g[1]},${g[2]}`)),e=Math.min(...t.map(g=>g[2])),i=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,-1,0],[-1,1,0],[1,0,-1],[-1,0,1],[0,1,-1],[0,-1,1]],s=[{normal:[1,0,0],key:"+X"},{normal:[-1,0,0],key:"-X"},{normal:[0,1,0],key:"+Y"},{normal:[0,-1,0],key:"-Y"},{normal:[0,0,1],key:"+Z"},{normal:[0,0,-1],key:"-Z"}],a=new Map;for(const g of t){const y=`${g[0]},${g[1]},${g[2]}`,m=g[2]===e,b=new Set;for(const d of i){const I=[g[0]+d[0],g[1]+d[1],g[2]+d[2]],k=`${I[0]},${I[1]},${I[2]}`;o.has(k)}for(const{normal:d,key:I}of s){const k=[g[0]+d[0],g[1]+d[1],g[2]+d[2]],E=`${k[0]},${k[1]},${k[2]}`;o.has(E)||b.add(I)}const x=b.size===0||b.size===1&&b.has("-Z")&&m;a.set(y,{isInterior:x,isBottomPlane:m,planes:b})}return a}function we(t,o){const e=new Set;let i=!1;for(const a of t){const g=`${a[0]},${a[1]},${a[2]}`,y=o.get(g);y&&(y.isInterior||y.isBottomPlane||(i=!0,Array.from(y.planes).forEach(m=>{m!=="-Z"&&e.add(m)})))}if(!i)return!0;const s=new Set;return Array.from(e).forEach(a=>{const g=a.slice(1);s.add(g)}),s.size>=2}function ye(t,o){const e=new Map;t.cells.forEach((y,m)=>e.set(_t(y),m));const i=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,-1,0],[-1,1,0],[1,0,-1],[-1,0,1],[0,1,-1],[0,-1,1]],s=t.cells.map(y=>{const m=[];for(const b of i){const x=[y[0]+b[0],y[1]+b[1],y[2]+b[2]],d=e.get(_t(x));d!==void 0&&m.push(d)}return m}),a=t.cells.length,g=(1n<<BigInt(a))-1n;return{id:t.id,cells:t.cells,bitIndex:e,neighbors:s,pieces:o,N:a,occMaskAll:g}}function Se(t,o){var O;const e=t.N,i=Math.ceil(e/64),s=dt(i);for(let w=0;w<e;w++)st(s,w);const a=((O=o==null?void 0:o.gravityConstraints)==null?void 0:O.enable)??!1,g=a?me(t.cells):null;let y=0,m=0;const b=Array.from({length:e},()=>it(i));for(let w=0;w<e;w++){const v=b[w];for(const c of t.neighbors[w])st(v,c)}const x=it(i),d=it(i);for(let w=0;w<e;w++){const v=t.cells[w];(v[0]+v[1]+v[2])%2===0?st(x,w):st(d,w)}let I=0x123456789abcdefn;function k(){return I^=I<<13n,I^=I>>17n,I^=I<<43n,I}const E=[];for(let w=0;w<e;w++)E.push(k());const P=new Map;for(const w of t.pieces.keys()){const c=[];for(let D=0;D<=10;D++)c.push(k());P.set(w,c)}const tt=Array.from({length:e},()=>[]);function B(w){const v=it(i),c=[];for(const D of w){const R=t.bitIndex.get(`${D[0]},${D[1]},${D[2]}`);if(R===void 0)return null;st(v,R),c.push(R)}return{mask:v,idx:c}}for(const[w,v]of t.pieces.entries())for(const c of v)for(const D of c.cells)for(let R=0;R<e;R++){const V=t.cells[R],C=V[0]-D[0],A=V[1]-D[1],$=V[2]-D[2],Y=c.cells.map(W=>[W[0]+C,W[1]+A,W[2]+$]),F=B(Y);if(!F)continue;if(g&&(m++,!we(Y,g))){y++;continue}const Z=[C,A,$];tt[R].push({pid:w,ori:c.id,t:Z,mask:F.mask,cellsIdx:F.idx})}for(let w=0;w<e;w++){const v=[],c=new Set;for(const D of tt[w]){const R=Ht(D.mask),V=`${D.pid}:${D.ori}:${R}`;c.has(V)||(c.add(V),v.push(D))}tt[w]=v}if(a&&m>0){const w=m-y;console.log(`üéØ Gravity constraints: filtered ${y}/${m} placements (${w} kept, ${(y/m*100).toFixed(1)}% rejected)`)}return{blockCount:i,occAllMask:s,candsByTarget:tt,neighborBits:b,color0Blocks:x,color1Blocks:d,zCell:E,zInv:P}}function it(t){return new BigUint64Array(t)}function dt(t){return new BigUint64Array(t)}function st(t,o){const e=o/64|0,i=BigInt(o%64);t[e]|=1n<<i}function jt(t,o){for(let e=0;e<t.length;e++)if((t[e]&o[e])!==0n)return!1;return!0}function be(t,o){for(let e=0;e<t.length;e++)t[e]|=o[e]}function xe(t,o){for(let e=0;e<t.length;e++)t[e]^=o[e]}function Ht(t){let o="";for(let e=0;e<t.length;e++)o+=t[e].toString(16)+"|";return o}function Et(t,o){for(let e=0;e<t.length;e++)if(t[e]!==o[e])return!1;return!0}function kt(t,o){const e=dt(t.length);for(let i=0;i<t.length;i++)e[i]=t[i]|o[i];return e}function Ut(t,o){const e=dt(t.length);for(let i=0;i<t.length;i++)e[i]=t[i]&o[i];return e}function Kt(t,o){const e=dt(t.length);for(let i=0;i<t.length;i++)e[i]=t[i]&~o[i];return e}function ft(t){let o=0;for(let e=0;e<t.length;e++){let i=t[e];for(;i;)i&=i-1n,o++}return o}function Ie(t,o){const e=o/64|0,i=BigInt(o%64);return(t[e]&1n<<i)!==0n}function Wt(t,o){const e=o/64|0,i=BigInt(o%64);return(t[e]&1n<<i)===0n}function Jt(t,o){for(let e=0;e<t.length;e++){let i=t[e];for(;i;){const s=i&-i,a=Number(ke(s)),g=e*64+a;o(g),i^=s}}}function ke(t){let o=0n,e=t;for(;(e&1n)===0n;)e>>=1n,o++;return o}class Me{constructor(o){z(this,"slots");z(this,"ways",2);z(this,"keys");z(this,"flags");this.slots=Math.floor(o/(this.ways*9)),this.keys=new BigUint64Array(this.slots*this.ways),this.flags=new Uint8Array(this.slots*this.ways)}lookup(o){const i=Number(o%BigInt(this.slots))*this.ways;for(let s=0;s<this.ways;s++){const a=i+s;if(this.keys[a]===o)return this.flags[a]}return 0}store(o,e){const s=Number(o%BigInt(this.slots))*this.ways;for(let a=0;a<this.ways;a++){const g=s+a;if(this.flags[g]===0||this.keys[g]===o){this.keys[g]=o,this.flags[g]=e;return}}this.keys[s]=o,this.flags[s]=e}}function $e(t,o,e,i){var Ot,Nt,Pt,zt;const s=Te(o),a=performance.now(),g=Ce(s.seed??12345);function y(n,r=0){for(let l=n.length-1;l>r;l--){const h=r+Math.floor(g()*(l-r+1));[n[l],n[h]]=[n[h],n[l]]}}const b=[...(((Ot=s.pieces)==null?void 0:Ot.allow)??[...t.pieces.keys()]).sort()],x={};for(const n of b)x[n]=Math.max(0,Math.floor(((Pt=(Nt=s.pieces)==null?void 0:Nt.inventory)==null?void 0:Pt[n])??1));const d=Se(t,o),I=new Map;for(const n of b)I.set(n,0);for(let n=0;n<t.N;n++)for(const r of d.candsByTarget[n])I.set(r.pid,(I.get(r.pid)??0)+1);b.sort((n,r)=>{const l=I.get(n)??0,h=I.get(r)??0;return l-h});const k=b.map(n=>`${n}:${I.get(n)}`).slice(0,8);if(console.log("üìä Piece order (most-constrained first):",k.join(", ")),s.shuffleStrategy==="initial"||s.shuffleStrategy==="periodicRestart"||s.shuffleStrategy==="periodicRestartTime"||s.shuffleStrategy==="adaptive"){const n=b.length,r=Math.max(3,Math.ceil(n/4));for(let l=0;l<n;l+=r){const h=Math.min(l+r,n),f=b.slice(l,h);y(f);for(let u=l;u<h;u++)b[u]=f[u-l]}console.log("üé≤ Shuffled within constraint bands")}const E=new Map;b.forEach((n,r)=>E.set(n,r));for(let n=0;n<t.N;n++)d.candsByTarget[n].sort((r,l)=>{const h=E.get(r.pid)??999,f=E.get(l.pid)??999;return h-f});console.log("üîÑ Candidates sorted by piece order");const P=d.candsByTarget.reduce((n,r)=>n+r.length,0),tt=d.candsByTarget.filter(n=>n.length>0).length;if(console.log(`üìã Candidates: ${P} total across ${tt}/${t.N} cells`),P===0){console.warn("‚ö†Ô∏è No candidates generated! Check piece orientations match container geometry.");const n=t.cells,r=Math.min(...n.map(p=>p[0])),l=Math.max(...n.map(p=>p[0])),h=Math.min(...n.map(p=>p[1])),f=Math.max(...n.map(p=>p[1])),u=Math.min(...n.map(p=>p[2])),M=Math.max(...n.map(p=>p[2]));console.log(`   Container range: i=[${r},${l}], j=[${h},${f}], k=[${u},${M}]`);const S=[...t.pieces.entries()][0];if(S){const[p,T]=S;console.log(`   First piece ${p}: ${T.length} orientations`),(zt=T[0])!=null&&zt.cells&&console.log(`   First orientation cells: ${JSON.stringify(T[0].cells)}`)}}let B=it(d.blockCount),O=0,w=0,v=0;const c=[];let D=0,R=0,V=0,C=0,A=!1,$=0,Y=0,F=a;const Z=new Map,W=new Set,ut=new Set;let Mt=0,$t=!1;const J=s.tt.enable?new Me(s.tt.bytes??64*1024*1024):null;let pt=0;J&&console.log(`üóÇÔ∏è  Engine2: TT enabled (${((s.tt.bytes??64*1024*1024)/(1024*1024)).toFixed(0)} MB, 2-way)`);let ht=0n;for(let n=0;n<t.N;n++)d.zCell&&d.zCell[n]!==void 0&&(ht^=d.zCell[n]);let rt=0n;for(const n in x){const r=d.zInv.get(n);if(r){const l=x[n]??0;rt^=r[Math.min(l,r.length-1)]}}function lt(){return ht^rt}function Ct(n){d.zCell&&Jt(n,r=>{d.zCell[r]!==void 0&&(ht^=d.zCell[r])})}function Tt(n,r,l){const h=d.zInv.get(n);h&&(rt^=h[Math.min(r,h.length-1)],rt^=h[Math.min(l,h.length-1)])}function vt(n){const r=new Map;for(const[h,f]of t.pieces.entries()){const u=new Map;for(const M of f)u.set(M.id,M.cells);r.set(h,u)}const l=[];for(const h of n){const f=r.get(h.pieceId);if(!f)throw new Error(`Unknown pieceId in solution: ${h.pieceId}`);const u=f.get(h.ori);if(!u)throw new Error(`Unknown orientation for ${h.pieceId}: ${h.ori}`);const M=u.map(p=>[p[0]+h.t[0],p[1]+h.t[1],p[2]+h.t[2]]),S=[];for(const p of M){const T=t.bitIndex.get(`${p[0]},${p[1]},${p[2]}`);if(T===void 0)throw new Error(`Solution cell outside container for ${h.pieceId}`);S.push(T)}S.sort((p,T)=>p-T),l.push(`${h.pieceId}:${S.join(",")}`)}return l.sort(),l.join("|")}let ct=!1,yt=!1,St=!1,et=a,bt=!1;const gt=s.view??{worldFromIJK:[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],sphereRadiusWorld:1},Vt=Math.floor(t.N/4),qt=Object.values(x).reduce((n,r)=>n+(r??0),0),Xt=Math.min(Vt,qt);let L={inventory:0,overlap:0,neighborTouch:0,colorResidue:0,multipleOf4:0,connectivity:0,ttPrune:0,total:0},Bt=performance.now(),mt=0,xt=0;function wt(){bt||(bt=!0,setTimeout(()=>{bt=!1,Gt()},0))}function Rt(n){var l,h;console.log(`üîÑ [RESTART] Triggering ${n}-based restart #${$+1} at ${O} nodes`),B=it(d.blockCount),c.length=0,D++,A=!0;for(const f of b)x[f]=Math.max(0,Math.floor(((h=(l=s.pieces)==null?void 0:l.inventory)==null?void 0:h[f])??1));y(b),$++;const r=new Map;b.forEach((f,u)=>r.set(f,u));for(let f=0;f<t.N;f++)d.candsByTarget[f].sort((u,M)=>{const S=r.get(u.pid)??999,p=r.get(M.pid)??999;return S-p});console.log("üîÑ Candidates resorted by new piece order"),ht=0n;for(let f=0;f<t.N;f++)d.zCell&&d.zCell[f]!==void 0&&(ht^=d.zCell[f]);rt=0n;for(const f in x){const u=d.zInv.get(f);if(u){const M=x[f]??0;rt^=u[Math.min(M,u.length-1)]}}Y=O,F=performance.now(),U("search")}const Gt=()=>{if(!yt){if(ct){wt();return}try{for(let r=0;r<200;r++){if(s.timeoutMs&&performance.now()-a>=s.timeoutMs){Q("timeout");return}if(s.shuffleStrategy==="periodicRestart"&&O-Y>=s.restartInterval&&$<s.maxRestarts){Rt("nodes");continue}if(s.shuffleStrategy==="periodicRestartTime"&&performance.now()-F>=s.restartIntervalSeconds*1e3&&$<s.maxRestarts){Rt("time");continue}if(c.length===0&&!At()){console.log("‚ùå [NO MOVES] Cannot push initial frame - no valid moves available"),console.log("   ‚îî‚îÄ This means the first piece cannot be placed anywhere (all positions pruned or invalid)"),Q("complete");return}if(s.tailSwitch.enable){const u=Kt(d.occAllMask,B),M=ft(u),S=s.tailSwitch.dlxThreshold??100;if(M>0&&M<=S){const p=lt();if(ut.has(p)){const q=c[c.length-1];if(j(q),c.pop(),c.length===0){Q("complete");return}const _=c[c.length-1];j(_),ot(_);const H=performance.now();H-et>=s.statusIntervalMs&&(U("search"),et=H);continue}if(J&&J.lookup(p)===1){const q=c[c.length-1];if(j(q),c.pop(),c.length===0){Q("complete");return}const _=c[c.length-1];j(_),ot(_);const H=performance.now();H-et>=s.statusIntervalMs&&(U("search"),et=H);continue}const T=s.tailSwitch.dlxTimeoutMs??3e4;ut.add(p),$t=!0;let N=!1;const K=[],Lt=performance.now(),at=pe({open:u,remaining:x,bb:d,timeoutMs:T,limit:1,wantWitness:!0});if(mt+=performance.now()-Lt,xt++,at.feasible&&at.witness&&at.witness.length>0){N=!0;const q=c.filter(X=>X.placed).map(X=>({pieceId:X.placed.pid,ori:X.placed.ori,t:X.placed.t})),_=at.witness.map(X=>({pieceId:X.pid,ori:X.ori,t:X.t})),H=[...q,..._],Ft=vt(H);!W.has(Ft)&&(W.add(Ft),K.push(H),v++,console.log(`‚úÖ Solution #${v} (DLX):`,H.map(X=>X.pieceId).join(",")),J&&(J.store(lt(),2),pt++),Dt(H),s.maxSolutions>0&&v>=s.maxSolutions&&(N=!0),s.pauseOnSolution&&(St=!0,ct=!0,U("search")))}if(N){if(s.maxSolutions>0&&v>=s.maxSolutions){Q("limit");return}if(ct)return;if(c.length){const q=c[c.length-1];for(q.placed&&j(q),ot(q);c.length>0&&!It(c[c.length-1]);){const _=c.pop();_.placed&&j(_)}if(c.length===0){Q("complete");return}U("search")}continue}else{J&&(J.store(lt(),1),pt++);const q=c[c.length-1];if(j(q),c.pop(),c.length===0){Q("complete");return}const _=c[c.length-1];j(_),ot(_);const H=performance.now();H-et>=s.statusIntervalMs&&(U("search"),et=H);continue}}}const l=c[c.length-1],h=ne(l);if(h){se(l,h),O++;const u=c.length,M=c.filter(p=>p.placed).length;if(u>R?(R=u,C=1,A=!1):R>0&&u===R&&A&&(C++,A=!1),M>V&&(V=M),u>Mt&&(Mt=u,ut.clear()),Et(B,d.occAllMask)){const p=c.filter(K=>K.placed).map(K=>({pieceId:K.placed.pid,ori:K.placed.ori,t:K.placed.t})),T=vt(p),N=!W.has(T);if(N){if(W.add(T),v++,console.log(`‚úÖ Solution #${v}:`,p.map(K=>K.pieceId).join(",")),J&&(J.store(lt(),2),pt++),Dt(p),s.maxSolutions>0&&v>=s.maxSolutions){Q("limit");return}if(s.pauseOnSolution&&N){ct=!0,U("search");return}}for(j(l),ot(l);c.length>0&&!It(c[c.length-1]);){const K=c.pop();K.placed&&j(K)}if(c.length===0){Q("complete");return}U("search");continue}At()||(j(l),ot(l));continue}if(J&&(J.store(lt(),1),pt++),j(l),c.pop(),R>0&&c.length<R&&(A=!0),c.length===0){Q("complete");return}if(s.shuffleStrategy==="adaptive"){const u=c.length;if(u<s.shuffleTriggerDepth){const M=u,S=Z.get(M)??0;if(S<s.maxSuffixShuffles){const T=c.filter(N=>N.placed).map(N=>N.placed.pid).length;T<b.length-1&&(console.log(`üß† [ADAPTIVE] Shuffling suffix at depth ${u} (shuffle #${S+1})`),y(b,T),console.log(`   ‚îî‚îÄ Kept first ${T} pieces, shuffled remaining ${b.length-T}`),Z.set(M,S+1),U("search"))}}}const f=c[c.length-1];j(f),ot(f)}const n=performance.now();n-et>=s.statusIntervalMs&&(U("search"),et=n)}catch(n){throw n}wt()}};function Yt(){ct=!0,U("search")}function Zt(){if(!yt){if(ct=!1,St&&(St=!1,c.length)){const n=c[c.length-1];for(n.placed&&j(n),ot(n);c.length>0&&!It(c[c.length-1]);){const r=c.pop();r.placed&&j(r)}}U("search"),wt()}}function Qt(){var n;yt=!0,(n=e==null?void 0:e.onDone)==null||n.call(e,{solutions:v,nodes:O,elapsedMs:performance.now()-a,reason:"canceled"})}function te(){const n=c.map(l=>({targetIdx:l.targetIdx,iPiece:l.iPiece,iOri:l.iOri,iAnchor:l.iAnchor,placed:l.placed?{pieceId:l.placed.pid,ori:l.placed.ori,t:l.placed.t,maskHex:Ht(l.placed.mask)}:void 0}));let r="";for(let l=0;l<B.length;l++)l>0&&(r+="|"),r+=B[l].toString(16);return{schema:2,N:t.N,occHex:r,pieceOrder:[...b],remaining:{...x},frames:n,nodes:O,solutions:v,elapsedMs:performance.now()-a,settings:s,containerId:t.id}}return U("search"),wt(),{pause:Yt,resume:Zt,cancel:Qt,snapshot:te};function ee(n){const r=ft(n);if(r&3)return!1;const l=ft(Ut(n,d.color0Blocks)),h=r-l;return!(l&1||h&1)}function oe(n,r){for(const l of n.cellsIdx){const h=d.neighborBits[l];for(let f=0;f<h.length;f++)if((h[f]&r[f])!==0n)return!0}return!1}function At(){const n=s.moveOrdering==="mostConstrainedCell"?re(B,x):ie(B,t.N);return n<0?!1:(c.push({targetIdx:n,iPiece:0,iOri:0,iAnchor:0,placed:void 0}),!0)}function ne(n){const r=d.candsByTarget[n.targetIdx],l=c.length;s.randomizeTies&&n.iAnchor===0&&r.length>1&&(n.iAnchor=Math.min(r.length-1,n.iAnchor+Math.floor(g()*(r.length-n.iAnchor))));let h=0,f={inventory:0,overlap:0,neighborTouch:0,colorResidue:0,multipleOf4:0,connectivity:0,ttPrune:0};for(;n.iAnchor<r.length;n.iAnchor++){h++;const u=r[n.iAnchor];if((x[u.pid]??0)<=0){L.inventory++,f.inventory++;continue}if(!jt(B,u.mask)){L.overlap++,f.overlap++;continue}const M=ft(B);if(s.pruning.neighborTouch&&M>0&&!oe(u,B)){w++,L.neighborTouch++,f.neighborTouch++;continue}if(s.pruning.colorResidue){const p=Kt(d.occAllMask,kt(B,u.mask));if(!ee(p)){w++,L.colorResidue++,f.colorResidue++;continue}}if(s.pruning.multipleOf4&&(t.N-ft(kt(B,u.mask)))%4!==0){w++,L.multipleOf4++,f.multipleOf4++;continue}if(s.pruning.connectivity&&!le(B,u.mask)){w++,L.connectivity++,f.connectivity++;continue}if(J){let p=lt();for(const at of u.cellsIdx)p^=d.zCell[at];const T=d.zInv.get(u.pid),N=x[u.pid]??0,K=N-1;if(p^=T[Math.min(N,T.length-1)],p^=T[Math.min(K,T.length-1)],J.lookup(p)===1){w++,L.ttPrune++,f.ttPrune++;continue}}const S=performance.now();if(S-Bt>=1e4){const p=Object.values(L).reduce((T,N)=>T+N,0);console.log(`üîç [PRUNING STATS] Depth ${l}, Total pruned: ${p.toLocaleString()}`),console.log(`   ‚îú‚îÄ Inventory: ${L.inventory.toLocaleString()}`),console.log(`   ‚îú‚îÄ Overlap: ${L.overlap.toLocaleString()}`),console.log(`   ‚îú‚îÄ NeighborTouch: ${L.neighborTouch.toLocaleString()}`),console.log(`   ‚îú‚îÄ ColorResidue: ${L.colorResidue.toLocaleString()}`),console.log(`   ‚îú‚îÄ MultipleOf4: ${L.multipleOf4.toLocaleString()}`),console.log(`   ‚îú‚îÄ Connectivity: ${L.connectivity.toLocaleString()}`),console.log(`   ‚îî‚îÄ TT Prune: ${L.ttPrune.toLocaleString()}`),Bt=S}return{pid:u.pid,ori:u.ori,t:u.t,mask:u.mask,cellsIdx:u.cellsIdx}}return h>0&&l<=5&&(console.log(`‚ùå [NO MOVES] Depth ${l}, checked ${h} candidates, all pruned`),console.log(`   ‚îú‚îÄ Inventory rejects: ${f.inventory}`),console.log(`   ‚îú‚îÄ Overlap rejects: ${f.overlap}`),console.log(`   ‚îú‚îÄ NeighborTouch rejects: ${f.neighborTouch}`),console.log(`   ‚îú‚îÄ ColorResidue rejects: ${f.colorResidue}`),console.log(`   ‚îú‚îÄ MultipleOf4 rejects: ${f.multipleOf4}`),console.log(`   ‚îú‚îÄ Connectivity rejects: ${f.connectivity}`),console.log(`   ‚îî‚îÄ TT rejects: ${f.ttPrune}`)),null}function se(n,r){be(B,r.mask),Ct(r.mask),Tt(r.pid,x[r.pid],x[r.pid]-1),x[r.pid]--,n.placed={pid:r.pid,ori:r.ori,t:r.t,mask:r.mask,cellsIdx:r.cellsIdx}}function j(n){if(!n.placed)return;const{pid:r,mask:l}=n.placed;xe(B,l),Ct(l),Tt(r,x[r],x[r]+1),x[r]++,n.placed=void 0}function ie(n,r){for(let l=0;l<r;l++)if(Wt(n,l))return l;return-1}function re(n,r){let l=-1,h=Number.POSITIVE_INFINITY;const f=t.N;for(let u=0;u<f;u++){if(!Wt(n,u))continue;let M=0;const S=d.candsByTarget[u];for(const p of S)if(!((r[p.pid]??0)<=0)&&jt(n,p.mask)&&(M++,M>=h))break;if(M<h&&(h=M,l=u,h===0))return u}return l}function le(n,r){const l=kt(n,r),h=dt(d.blockCount);for(let S=0;S<d.blockCount;S++)h[S]=~l[S]&d.occAllMask[S];let f=-1;t:for(let S=0;S<d.blockCount;S++){let p=h[S];if(p===0n)continue;let T=0n;for(;(p&1n)===0n;)p>>=1n,T++;f=S*64+Number(T);break t}if(f<0)return!0;const u=it(d.blockCount),M=[f];for(st(u,f);M.length;){const S=M.pop(),p=d.neighborBits[S],T=Ut(p,h);Jt(T,N=>{Ie(u,N)||(st(u,N),M.push(N))})}return Et(u,h)}function ot(n){n.iAnchor++}function It(n){const r=d.candsByTarget[n.targetIdx];for(let l=n.iAnchor;l<r.length;l++){const h=r[l];if((x[h.pid]??0)>0)return!0}return!1}function Dt(n){var l,h,f;Y=O,F=performance.now();const r={engine:"dfs",phase:"search",nodes:O,depth:c.length,elapsedMs:performance.now()-a,pruned:w,placed:n.length,open_cells:0,stack:n,containerId:t.id,worldFromIJK:gt.worldFromIJK,sphereRadiusWorld:gt.sphereRadiusWorld,clear:!0,scene_version:++D};(l=s.pieces)!=null&&l.inventory&&(r.inventory_remaining={...x}),(h=e==null?void 0:e.onStatus)==null||h.call(e,r),(f=e==null?void 0:e.onSolution)==null||f.call(e,n),s.saveSolutions&&(e!=null&&e.onSaveSolutionFile)&&e.onSaveSolutionFile({index:v,placements:n,containerId:t.id,nodes:O,elapsedMs:performance.now()-a})}function U(n){var u,M;const r=c.filter(S=>S.placed).map(S=>({pieceId:S.placed.pid,ori:S.placed.ori,t:S.placed.t})),l=performance.now()-a,h=l>0?Math.round(O/l*1e3):0,f={engine:"dfs",phase:n,nodes:O,depth:c.length,elapsedMs:l,pruned:w,placed:r.length,open_cells:t.N-ft(B),stack:r,containerId:t.id,worldFromIJK:gt.worldFromIJK,sphereRadiusWorld:gt.sphereRadiusWorld,clear:!1,scene_version:D,bestDepth:R,maxDepthHits:C,bestPlaced:V,totalPiecesTarget:Xt,nodesPerSec:h,tailTriggered:$t,restartCount:$,shuffleStrategy:s.shuffleStrategy,restartInterval:s.restartInterval,restartIntervalSeconds:s.restartIntervalSeconds};(u=s.pieces)!=null&&u.inventory&&(f.inventory_remaining={...x}),(M=e==null?void 0:e.onStatus)==null||M.call(e,f),et=performance.now()}function Q(n){var l;const r=performance.now()-a;console.log(`‚úÖ DONE: ${O} nodes | ${v} solutions | ${(r/1e3).toFixed(1)}s`),console.log(`üìä Timing: DLX ${mt.toFixed(0)}ms (${xt} calls), DFS ${(r-mt).toFixed(0)}ms`),U("done"),(l=e==null?void 0:e.onDone)==null||l.call(e,{solutions:v,nodes:O,elapsedMs:performance.now()-a,reason:n,timing:{totalMs:r,dlxMs:mt,dlxCalls:xt,pruneStats:{...L},restartCount:$,bestDepth:R,maxDepthHits:C}})}}function _t(t){return`${t[0]},${t[1]},${t[2]}`}function Ce(t){let o=t|0||1;return()=>(o^=o<<13,o^=o>>>17,o^=o<<5,(o>>>0)/4294967296)}function Te(t){var o,e,i,s,a,g,y,m,b,x,d,I,k;return{maxSolutions:t.maxSolutions??0,timeoutMs:t.timeoutMs??0,statusIntervalMs:t.statusIntervalMs??250,pauseOnSolution:t.pauseOnSolution??!0,saveSolutions:t.saveSolutions??!1,savePath:t.savePath??"",moveOrdering:t.moveOrdering??"mostConstrainedCell",pruning:{connectivity:((o=t.pruning)==null?void 0:o.connectivity)??!0,multipleOf4:((e=t.pruning)==null?void 0:e.multipleOf4)??!0,colorResidue:((i=t.pruning)==null?void 0:i.colorResidue)??!0,neighborTouch:((s=t.pruning)==null?void 0:s.neighborTouch)??!0},pieces:t.pieces??{},view:t.view??{worldFromIJK:[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],sphereRadiusWorld:1},seed:t.seed??12345,randomizeTies:t.randomizeTies??!0,shuffleStrategy:t.shuffleStrategy??"none",restartInterval:t.restartInterval??5e4,restartIntervalSeconds:t.restartIntervalSeconds??5,maxRestarts:t.maxRestarts??10,shuffleTriggerDepth:t.shuffleTriggerDepth??8,maxSuffixShuffles:t.maxSuffixShuffles??5,tt:{enable:((a=t.tt)==null?void 0:a.enable)??!0,bytes:((g=t.tt)==null?void 0:g.bytes)??64*1024*1024,policy:((y=t.tt)==null?void 0:y.policy)??"2way"},tailSwitch:{enable:((m=t.tailSwitch)==null?void 0:m.enable)??!0,dlxThreshold:((b=t.tailSwitch)==null?void 0:b.dlxThreshold)??60,dlxTimeoutMs:((x=t.tailSwitch)==null?void 0:x.dlxTimeoutMs)??3e4},visualRevealDelayMs:t.visualRevealDelayMs??150,parallel:{enable:((d=t.parallel)==null?void 0:d.enable)??!1,workerCount:((I=t.parallel)==null?void 0:I.workerCount)??(typeof navigator<"u"?navigator.hardwareConcurrency:4)},gravityConstraints:{enable:((k=t.gravityConstraints)==null?void 0:k.enable)??!1}}}let nt=-1,G=null;self.onmessage=t=>{const o=t.data;switch(o.type){case"init":{nt=o.workerId;const e=new Map(o.pieceDB),i={...o.settings,seed:(o.settings.seed??Date.now())+nt*1e3};try{const s=ye({cells:o.geometry,id:`worker-${nt}`},e);G=$e(s,i,{onStatus:a=>{const g={nodes:a.nodes??0,depth:a.depth??0,bestDepth:a.bestDepth??a.depth??0,maxDepthHits:a.maxDepthHits??0,elapsedMs:a.elapsedMs??0,nodesPerSec:a.nodesPerSec??0,restartCount:a.restartCount??0};self.postMessage({type:"status",workerId:nt,status:g})},onSolution:a=>{self.postMessage({type:"solution",workerId:nt,placements:a})},onDone:a=>{self.postMessage({type:"done",workerId:nt,summary:{solutions:a.solutions,nodes:a.nodes,elapsedMs:a.elapsedMs,reason:a.reason}})}}),G.resume(),self.postMessage({type:"ready",workerId:nt})}catch(s){self.postMessage({type:"error",workerId:nt,error:s instanceof Error?s.message:String(s)})}break}case"pause":{G==null||G.pause();break}case"resume":{G==null||G.resume();break}case"cancel":{G==null||G.cancel();break}}};
