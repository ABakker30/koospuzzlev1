let g,p,d,m=!1;async function k(){if(m)return;console.log("ðŸ”§ [Worker] Loading engine functions...");const e=await import("./hintEngine-NFocXqf7.js");g=e.loadHintEnginePiecesDb,p=e.checkSolvableFromPartial,d=e.computeStatsFromPartial,m=!0,console.log("âœ… [Worker] Engine functions loaded")}let s=null;const i=new Set;function h(e){return{...e,emptyCells:[...e.emptyCells].sort((o,l)=>o.i!==l.i?o.i-l.i:o.j!==l.j?o.j-l.j:o.k-l.k),remainingPieces:[...e.remainingPieces].sort(),placedPieces:[...e.placedPieces].sort((o,l)=>(o.uid||o.pieceId||"").localeCompare(l.uid||l.pieceId||""))}}async function C(e,o,l,y){try{if(await k(),s||(console.log("ðŸ”§ [Worker] Loading pieces database..."),s=await g(),console.log("âœ… [Worker] Pieces database loaded")),i.has(e)){i.delete(e);return}const n=h(o);console.log(`ðŸ” [Worker ${e}] Starting solvability check...`,{emptyCells:n.emptyCells.length,placedPieces:n.placedPieces.length,remainingPieces:n.remainingPieces.filter(u=>u.remaining>0).length});const a=performance.now(),t=await p(n,s);if(console.log(`ðŸ“Š [Worker ${e}] Raw solvable result:`,{solvable:t.solvable,mode:t.mode,emptyCount:t.emptyCount,definiteFailure:t.definiteFailure,solutionCount:t.solutionCount}),i.has(e)){i.delete(e);return}let r={};if(t.mode==="full"&&t.solvable&&(console.log(`ðŸ“Š [Worker ${e}] Computing stats...`),r=await d(n,s),i.has(e))){i.delete(e);return}const f=performance.now()-a;console.log(`âœ… [Worker ${e}] Complete in ${f.toFixed(0)}ms`);const c={requestId:e,result:{...t,...r}};console.log(`ðŸ“¤ [Worker ${e}] Sending response:`,c),self.postMessage(c)}catch(n){console.error(`âŒ [Worker ${e}] Error:`,n);const a={requestId:e,error:String(n)};self.postMessage(a)}}function P(e){console.log(`ðŸ›‘ [Worker] Cancelling request ${e}`),i.add(e)}self.addEventListener("message",e=>{const o=e.data;o.type==="check"?C(o.requestId,o.input,o.timeoutMs,o.emptyThreshold):o.type==="cancel"&&P(o.requestId)});console.log("ðŸš€ [Worker] DLX Worker initialized");
