var q=Object.defineProperty;var J=(t,o,n)=>o in t?q(t,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[o]=n;var S=(t,o,n)=>J(t,typeof o!="symbol"?o+"":o,n);function Q(t,o){for(let n=0;n<t.length;n++){let e=t[n];for(;e;){const s=e&-e,i=Z(s);o(n*64+i),e^=s}}}function Z(t){let o=0,n=t;for(;(n&1n)===0n;)n>>=1n,o++;return o}function tt(t,o){for(let n=0;n<t.length;n++)if((t[n]&~o[n])!==0n)return!1;return!0}class nt{constructor(o,n,e){S(this,"L");S(this,"R");S(this,"U");S(this,"D");S(this,"C");S(this,"rowId");S(this,"colSize");S(this,"nCols");S(this,"nPrimary");S(this,"root",0);S(this,"nodeCount");S(this,"colHeadBase",1);this.nCols=o,this.nPrimary=n,this.L=new Int32Array(e),this.R=new Int32Array(e),this.U=new Int32Array(e),this.D=new Int32Array(e),this.C=new Int32Array(e),this.rowId=new Int32Array(e),this.colSize=new Int32Array(this.colHeadBase+o+1),this.L[this.root]=this.root,this.R[this.root]=this.root,this.U[this.root]=this.root,this.D[this.root]=this.root;for(let s=1;s<=o;s++)this.C[s]=s,this.colSize[s]=0,this.U[s]=s,this.D[s]=s,this.L[s]=s-1,this.R[s]=s===o?this.root:s+1;this.L[1]=this.root,this.R[this.root]=o>=1?1:this.root,this.L[this.root]=o>=1?o:this.root,this.nodeCount=o+1}addRow(o,n){let e=-1,s=-1;for(let i=0;i<n.length;i++){const f=n[i],l=this.colHeadBase+f,c=this.nodeCount++;this.C[c]=l,this.rowId[c]=o;const u=this.U[l];if(this.U[c]=u,this.D[c]=l,this.D[u]=c,this.U[l]=c,this.colSize[l]++,e<0)e=c,s=c,this.L[c]=c,this.R[c]=c;else{const m=this.R[s];this.R[s]=c,this.L[c]=s,this.R[c]=m,this.L[m]=c,s=c}}}cover(o){this.R[this.L[o]]=this.R[o],this.L[this.R[o]]=this.L[o];for(let n=this.D[o];n!==o;n=this.D[n])for(let e=this.R[n];e!==n;e=this.R[e]){const s=this.C[e];this.D[this.U[e]]=this.D[e],this.U[this.D[e]]=this.U[e],this.colSize[s]--}}uncover(o){for(let n=this.U[o];n!==o;n=this.U[n])for(let e=this.L[n];e!==n;e=this.L[e]){const s=this.C[e];this.colSize[s]++,this.D[this.U[e]]=e,this.U[this.D[e]]=e}this.R[this.L[o]]=o,this.L[this.R[o]]=o}choosePrimaryColumnMinSize(){let o=-1,n=2147483647;for(let e=this.R[this.root];e!==this.root;e=this.R[e]){if(e-this.colHeadBase>=this.nPrimary)continue;const i=this.colSize[e];if(i<n&&(n=i,o=e,n<=1))break}return o}solve(o){const n=performance.now();let e=0,s=!1,i="complete";const f=[];let l;const c=m=>{if(performance.now()>=o.deadlineMs)return i="timeout",!1;let d=!1;for(let r=this.R[this.root];r!==this.root;r=this.R[r])if(r-this.colHeadBase<this.nPrimary){d=!0;break}if(!d)return e++,o.wantWitness&&!l&&(l=f.slice()),e>=o.limit?(s=!0,i="limit",!1):!0;const g=this.choosePrimaryColumnMinSize();if(g<0||this.colSize[g]===0)return!0;this.cover(g);for(let r=this.D[g];r!==g;r=this.D[r]){f.push(this.rowId[r]);for(let a=this.R[r];a!==r;a=this.R[a])this.cover(this.C[a]);const h=c();for(let a=this.L[r];a!==r;a=this.L[a])this.uncover(this.C[a]);if(f.pop(),!h&&(i==="limit"||i==="timeout"))return this.uncover(g),!1}return this.uncover(g),!0};c();const u=performance.now()-n;return{count:e,capped:s,reason:i,witness:l,elapsedMs:u}}}function ot(t){const o=performance.now(),n=t.limit??1e3,e=t.timeoutMs??0,s=e>0?performance.now()+e:Number.POSITIVE_INFINITY,i=!1,f=[];Q(t.open,I=>f.push(I));const l=f.length;if(l===0)return{feasible:!0,count:1,capped:!1,witness:i?[]:void 0,elapsedMs:performance.now()-o,reason:"complete"};const c=[];for(const I of Object.keys(t.remaining)){const w=Math.max(0,t.remaining[I]??0);for(let b=0;b<w;b++)c.push({pid:I,inst:b})}const u=c.length,m=l+u,d=new Map;for(let I=0;I<f.length;I++)d.set(f[I],I);const g=new Map;{let I=l;for(const w of Object.keys(t.remaining)){const b=Math.max(0,t.remaining[w]??0);b>0&&g.set(w,I),I+=b}}const r=[],h=new Set;for(const I of f){const w=t.bb.candsByTarget[I]??[];for(const b of w){if(!tt(b.mask,t.open)||(t.remaining[b.pid]??0)<=0)continue;const P=`${b.pid}:${b.ori}:${b.t.i},${b.t.j},${b.t.k}:${et(b.mask)}`;h.has(P)||(h.add(P),r.push({pid:b.pid,ori:b.ori,t:b.t,mask:b.mask,cellsIdx:b.cellsIdx}))}}if(r.length===0)return{feasible:!1,count:0,capped:!1,elapsedMs:performance.now()-o,reason:"complete"};let a=1+m;for(const I of r){const w=Math.max(0,t.remaining[I.pid]??0);a+=5*w}const k=new nt(m,l,a),p=[];for(let I=0;I<r.length;I++){const w=r[I],b=Math.max(0,t.remaining[w.pid]??0),D=g.get(w.pid);if(D===void 0)continue;const P=[];for(const E of w.cellsIdx){const R=d.get(E);if(R===void 0){P.length=0;break}P.push(R)}if(P.length===4)for(let E=0;E<b;E++){const R=p.length;p.push(w);const K=P.concat([D+E]);k.addRow(R,K)}}const{count:y,capped:M,reason:x,witness:B,elapsedMs:A}=k.solve({limit:n,deadlineMs:s,wantWitness:i}),v=y>0,C=v&&i&&B?B.map(I=>p[I]):void 0;return{feasible:v,count:y,capped:M,witness:C,elapsedMs:A,reason:x}}function et(t){let o="";for(let n=0;n<t.length;n++)o+=t[n].toString(16)+"|";return o}function z(t,o){const n=new Map;t.cells.forEach((l,c)=>n.set(F(l),c));const e=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,-1,0],[-1,1,0],[1,0,-1],[-1,0,1],[0,1,-1],[0,-1,1]],s=t.cells.map(l=>{const c=[];for(const u of e){const m=[l[0]+u[0],l[1]+u[1],l[2]+u[2]],d=n.get(F(m));d!==void 0&&c.push(d)}return c}),i=t.cells.length,f=(1n<<BigInt(i))-1n;return{id:t.id,cells:t.cells,bitIndex:n,neighbors:s,pieces:o,N:i,occMaskAll:f}}function st(t){const o=t.N,n=Math.ceil(o/64),e=j(n);for(let r=0;r<o;r++)$(e,r);const s=Array.from({length:o},()=>N(n));for(let r=0;r<o;r++){const h=s[r];for(const a of t.neighbors[r])$(h,a)}const i=N(n),f=N(n);for(let r=0;r<o;r++){const h=t.cells[r];(h[0]+h[1]+h[2])%2===0?$(i,r):$(f,r)}let l=0x123456789abcdefn;function c(){return l^=l<<13n,l^=l>>17n,l^=l<<43n,l}const u=[];for(let r=0;r<o;r++)u.push(c());const m=new Map;for(const r of t.pieces.keys()){const a=[];for(let k=0;k<=10;k++)a.push(c());m.set(r,a)}const d=Array.from({length:o},()=>[]);function g(r){const h=N(n),a=[];for(const k of r){const p=t.bitIndex.get(`${k[0]},${k[1]},${k[2]}`);if(p===void 0)return null;$(h,p),a.push(p)}return{mask:h,idx:a}}for(const[r,h]of t.pieces.entries())for(const a of h)for(const k of a.cells)for(let p=0;p<o;p++){const y=t.cells[p],M=y[0]-k[0],x=y[1]-k[1],B=y[2]-k[2],A=a.cells.map(I=>[I[0]+M,I[1]+x,I[2]+B]),v=g(A);if(!v)continue;const C=[M,x,B];d[p].push({pid:r,ori:a.id,t:C,mask:v.mask,cellsIdx:v.idx})}for(let r=0;r<o;r++){const h=[],a=new Set;for(const k of d[r]){const p=it(k.mask),y=`${k.pid}:${k.ori}:${p}`;a.has(y)||(a.add(y),h.push(k))}d[r]=h}return{blockCount:n,occAllMask:e,candsByTarget:d,neighborBits:s,color0Blocks:i,color1Blocks:f,zCell:u,zInv:m}}function N(t){return new BigUint64Array(t)}function j(t){return new BigUint64Array(t)}function $(t,o){const n=o/64|0,e=BigInt(o%64);t[n]|=1n<<e}function it(t){let o="";for(let n=0;n<t.length;n++)o+=t[n].toString(16)+"|";return o}function ct(t,o){const n=j(t.length);for(let e=0;e<t.length;e++)n[e]=t[e]&~o[e];return n}function O(t,o){for(let n=0;n<t.length;n++){let e=t[n];for(;e;){const s=e&-e,i=Number(lt(s)),f=n*64+i;o(f),e^=s}}}function lt(t){let o=0n,n=t;for(;(n&1n)===0n;)n>>=1n,o++;return o}function F(t){return`${t[0]},${t[1]},${t[2]}`}const U={HINT_THRESHOLD:100,SOLVE_THRESHOLD:100,COUNT_LIMIT:1e5,TIMEOUT_MS:3e5};async function rt(){try{console.log("üì¶ Loading pieces from pieces_orientations.py...");const o=await(await fetch("/data/Pieces/pieces_orientations.py")).text(),n=at(o);return console.log(`‚úÖ Loaded ${n.size} pieces with orientations`),n}catch(t){throw console.error("‚ùå Failed to load pieces:",t),t}}function at(t){console.log("üîç parsePythonPieces: Parsing Python code..."),console.log(`   Code length: ${t.length} chars`);const o=new Map,n=t.match(/PIECES\s*=\s*\{([\s\S]*)\}/);if(!n)throw console.error("‚ùå parsePythonPieces: Could not find PIECES dictionary"),new Error("Could not find PIECES dictionary in Python file");console.log("‚úÖ parsePythonPieces: Found PIECES dictionary");const e=n[1],s=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y"];for(const i of s){const l=new RegExp(`"${i}":\\s*\\[`).exec(e);if(!l)continue;let c=1,u=l.index+l[0].length;for(;u<e.length&&c>0;)e[u]==="["?c++:e[u]==="]"&&c--,u++;const m=e.substring(l.index+l[0].length,u-1),d=[],g=/\[\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\],\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\],\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\],\s*\[\s*(-?\d+),\s*(-?\d+),\s*(-?\d+)\s*\]\s*\]/g;let r=0,h;for(;(h=g.exec(m))!==null;){const a=[[parseInt(h[1]),parseInt(h[2]),parseInt(h[3])],[parseInt(h[4]),parseInt(h[5]),parseInt(h[6])],[parseInt(h[7]),parseInt(h[8]),parseInt(h[9])],[parseInt(h[10]),parseInt(h[11]),parseInt(h[12])]];d.push({id:r++,cells:a})}d.length>0&&(o.set(i,d),console.log(`  ${i}: ${d.length} orientations`))}return console.log(`üì¶ Total pieces parsed: ${o.size} (expected 25: A-Y)`),console.log(`üì¶ Piece IDs found: ${Array.from(o.keys()).join(", ")}`),o}let ft=null;function ut(t){return`${t.i},${t.j},${t.k}`}function ht(t){return Array.isArray(t)?`${t[0]},${t[1]},${t[2]}`:`${t.i},${t.j},${t.k}`}function L(t){let o=0;for(;t;)t&=t-1n,o++;return o}function dt(t,o){const n=j(o);for(let e=0;e<o;e++){const s=(1n<<64n)-1n;n[e]=t>>BigInt(e*64)&s}return n}function T(t,o,n,e){let s=0n;for(const i of o){const f=[i[0]+n[0],i[1]+n[1],i[2]+n[2]],l=t.bitIndex.get(ht(f));if(l===void 0)return null;const c=1n<<BigInt(l);if(e&c)return null;s|=c}return s}function H(t,o,n){const e=o|n;if(e===t.occMaskAll)return!0;const s=t.N;let i=-1;for(let u=0;u<s;u++){const m=1n<<BigInt(u);if((e&m)===0n){i=u;break}}if(i<0)return!0;const f=~e&t.occMaskAll;let l=0n;const c=[i];for(l|=1n<<BigInt(i);c.length;){const u=c.shift();for(const m of t.neighbors[u]){const d=1n<<BigInt(m);f&d&&!(l&d)&&(l|=d,c.push(m))}}return l===f}function _(t,o){if((t.N-L(o))%4!==0)return!1;const e=~o&t.occMaskAll;let s=-1;for(let l=0;l<t.N;l++){const c=1n<<BigInt(l);if(e&c){s=l;break}}if(s<0)return!0;let i=0n;const f=[s];for(i|=1n<<BigInt(s);f.length;){const l=f.shift();for(const c of t.neighbors[l]){const u=1n<<BigInt(c);e&u&&!(i&u)&&(i|=u,f.push(c))}}return i===e}function X(t,o,n,e){let s=-1,i=Number.POSITIVE_INFINITY;for(let f=0;f<t.N;f++){const l=1n<<BigInt(f);if(o&l)continue;let c=0;for(const[u,m]of e.entries())if(!((n[u]??0)<=0)){for(const d of m){for(const g of d.cells){const r=[t.cells[f][0]-g[0],t.cells[f][1]-g[1],t.cells[f][2]-g[2]];if(T(t,d.cells,r,o)!==null&&(c++,c>=i))break}if(c>=i)break}if(c>=i)break}if(c<i&&(i=c,s=f,i===0))return f}return s}function V(t,o){let n=0n,e=0,s=0,i=0;for(const f of o){let l=0,c=0;for(const u of f.cells){e++;const m=t.bitIndex.get(ut(u));m!=null?(n|=1n<<BigInt(m),s++,l++):(i++,c++)}c>0&&console.warn("‚ö†Ô∏è [buildOccMask] Piece has cells outside container:",{pieceId:f.pieceId,totalCells:f.cells.length,inContainer:l,outside:c,cells:f.cells})}return console.log("üî¢ [buildOccMask] Summary:",{placedPiecesCount:o.length,totalCells:e,inContainer:s,outside:i,occBits:L(n),containerSize:t.N}),n}function Y(t){const o={};for(const n of t)n.remaining==="infinite"?o[n.pieceId]=999:o[n.pieceId]=Math.max(0,n.remaining);return o}function G(t,o,n,e,s,i){if(console.log("üîé dfsSolvable start",{depth:e,occ:n.occ.toString(16)}),Date.now()>i||e>s)return!1;if(n.occ===t.occMaskAll)return console.log("‚úÖ Solution found at depth",e),!0;const f=X(t,n.occ,n.remaining,o);if(f<0)return console.log("‚ö†Ô∏è No target cell selected (dead end)"),!1;const l=t.cells[f];if(e===0){console.log("üîé Debug at depth 0:"),console.log("  target:",l),console.log("  piecesDb type:",o instanceof Map?"Map":"Object"),console.log("  piecesDb keys sample:",o instanceof Map?Array.from(o.keys()).slice(0,3):Object.keys(o).slice(0,3));const g=o instanceof Map?o.values().next().value:Object.values(o)[0];g&&g[0]&&(console.log("  first orientation sample:",g[0]),console.log("  has cells?","cells"in g[0]),console.log("  has ijkOffsets?","ijkOffsets"in g[0]))}let c=0,u=0,m=0,d=0;for(const[g,r]of o.entries())if(!((n.remaining[g]??0)<=0))for(const h of r)for(const a of h.cells){const k=[l[0]-a[0],l[1]-a[1],l[2]-a[2]],p=T(t,h.cells,k,n.occ);if(p===null){u++;continue}c++;const y=t.N-L(n.occ|p);if(y%4!==0){m++,e<=2&&console.log("üö´ dfsSolvable prune: mod4",{depth:e,openAfter:y,occHex:n.occ.toString(16),maskHex:p.toString(16)});continue}if(!H(t,n.occ,p)){d++,e<=2&&console.log("üö´ dfsSolvable prune: connectivity",{depth:e,openAfter:y,occHex:n.occ.toString(16),maskHex:p.toString(16)});continue}if(n.occ|=p,n.remaining[g]--,G(t,o,n,e+1,s,i))return!0;n.occ&=~p,n.remaining[g]++}return console.log("üîé dfsSolvable at depth",e,{targetIdx:f,candidateCount:c,prunedByMask:u,prunedByMod4:m,prunedByConnectivity:d}),!1}function W(t,o,n,e,s,i,f=1e3){if(Date.now()>i||e>s)return 0;if(n.occ===t.occMaskAll)return 1;const l=X(t,n.occ,n.remaining,o);if(l<0)return 0;const c=t.cells[l];let u=0;for(const[m,d]of o.entries())if(!((n.remaining[m]??0)<=0)){if(u>=f)break;for(const g of d)for(const r of g.cells){if(u>=f)break;const h=[c[0]-r[0],c[1]-r[1],c[2]-r[2]],a=T(t,g.cells,h,n.occ);a===null||(t.N-L(n.occ|a))%4!==0||H(t,n.occ,a)&&(n.occ|=a,n.remaining[m]--,u+=W(t,o,n,e+1,s,i,f-u),n.occ&=~a,n.remaining[m]++)}}return u}async function pt(){return await rt()}async function It(t,o){console.log("üì• [checkSolvableFromPartial] Input:",{containerCells:t.containerCells.length,placedPieces:t.placedPieces.length,placedPieceIds:t.placedPieces.map(a=>a.pieceId),remainingPieces:t.remainingPieces.length,mode:t.mode});const n=t.containerCells.map(a=>[a.i,a.j,a.k]),e=z({cells:n,id:t.mode},o),s=V(e,t.placedPieces);let i=Y(t.remainingPieces);const f=e.N-L(s),l=Math.ceil(f/4)+2;if(t.mode==="single")for(const a of Object.keys(i))i[a]>l&&(i[a]=l);const c=f<=U.SOLVE_THRESHOLD;if(console.log("üß© [HintEngine] partial state for solvability:",{N:e.N,mode:t.mode,remaining:i,emptyCount:f,checkMode:c?"full":"lightweight"}),c&&f<=U.SOLVE_THRESHOLD){console.log("üéØ [HintEngine] Using DLX for solvability check (N=",f,")");try{const a=st(e),k=dt(s,a.blockCount),p=ct(a.occAllMask,k);let y=0;O(a.occAllMask,()=>{y++});let M=0;O(k,()=>{M++});let x=0;O(p,()=>{x++}),console.log("üîç [DLX Bitboard Check]:",{N:e.N,containerMaskBits:y,occBlocksBits:M,openBlocksBits:x,emptyCount:f});const B=t.mode==="single",A=B?1:1e3;console.log("üîç [SOLVABILITY-DEBUG] Starting DLX solvability check with limit:",A,"mode:",t.mode);const v=performance.now(),C=ot({open:p,remaining:i,bb:a,timeoutMs:B?5e3:U.TIMEOUT_MS,limit:A,wantWitness:!1});if(console.log("üîç [SOLVABILITY-DEBUG] DLX solvability check took",(performance.now()-v).toFixed(0),"ms"),console.log("üéØ [DLX] Result:",{feasible:C.feasible,count:C.count,capped:C.capped,elapsedMs:C.elapsedMs}),!C.feasible){let I=0;O(p,()=>{I++}),console.error("‚ùå [DLX] INFEASIBLE STATE:",{N:e.N,emptyCount:f,remaining:i,openCellsCount:I,containerCells:t.containerCells.length,placedPieces:t.placedPieces.length})}return{solvable:C.feasible,mode:"full",emptyCount:f,solutionCount:C.count,solutionsCapped:C.capped}}catch(a){console.warn("‚ö†Ô∏è [DLX] Failed, falling back to DFS:",a)}}if(!c){const a=_(e,s);return{solvable:a,mode:"lightweight",emptyCount:f,definiteFailure:!a}}const u=Date.now(),m=u+4e3,d=100,r=G(e,o,{occ:s,remaining:i},0,d,m);let h;if(r){const a={occ:s,remaining:{...i}},k=u+2e3;h=W(e,o,a,0,d,k,1e3),console.log(`üî¢ [HintEngine] Found ${h}${h>=1e3?"+":""} solutions`)}return{solvable:r,mode:"full",emptyCount:f,solutionCount:h}}async function kt(t,o){const n=t.containerCells.map(d=>[d.i,d.j,d.k]),e=z({cells:n,id:t.mode},o),s=V(e,t.placedPieces),i=Y(t.remainingPieces),f=e.N-L(s);console.log("üìä [Stats] Computing stats for partial state:",{emptyCount:f,remaining:i});let l=0;const c=gt(s,e.N);if(c!==null){const d=e.cells[c];for(const g of Object.keys(i)){if(i[g]<=0)continue;const r=o.get(g);if(r)for(const h of r){const a=h.cells;if(a.length===0)continue;const k=[d[0]-a[0][0],d[1]-a[0][1],d[2]-a[0][2]],p=T(e,a,k,s);if(!p)continue;const y=s|p;(e.N-L(y)===0||_(e,y))&&l++}}}const u=Object.values(i).reduce((d,g)=>d+g,0);let m;if(f>0&&u>0){const d=Math.min(u*5,50),g=Math.min(f,u),r=Math.pow(d,g);r>1e6?m=`‚âà10^${Math.floor(Math.log10(r))}`:r>1e3?m=`‚âà${(r/1e3).toFixed(1)}K`:m=`‚âà${Math.floor(r)}`}return console.log("üìä [Stats] Results:",{validNextMoveCount:l,estimatedSearchSpace:m}),{estimatedSearchSpace:m,validNextMoveCount:l}}function gt(t,o){for(let n=0;n<o;n++){const e=1n<<BigInt(n);if(!(t&e))return n}return null}export{It as checkSolvableFromPartial,kt as computeStatsFromPartial,pt as loadHintEnginePiecesDb};
